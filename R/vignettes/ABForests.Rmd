---
title: "ABForests vignette"
author: "Chrysa Papadopoulou"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ABForests vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
#to avoid of the dplyr summarise warnings
library(dplyr, warn.conflicts = FALSE)
options(dplyr.summarise.inform = FALSE)
library(stats, warn.conflicts = F)

knitr::opts_chunk$set(fig.width=7, fig.height=7) 
```

```{r, eval = FALSE, include=FALSE}
#this is for sourcing all functions under development and is not included in the knitting
source_code_dir <- "C:/Dokumente usw/Master/Reddy Lab/1_thesis/3_code/4_DB project/PlatypusDB_admin/R" 
file_path_vec <- list.files(source_code_dir, full.names = T)
for(f_path in file_path_vec){
  print(f_path)
  tryCatch({source(f_path)}, error = function(e){e})
}

knitr::opts_chunk$set(fig.width=7, fig.height=7) 

gc()

load("C:/Dokumente usw/Master/Reddy Lab/1_thesis/3_code/4_DB project/PlatypusDB_dev_VK/R/ABForests_sysdata.rda")

load("C:/Dokumente usw/Master/Reddy Lab/1_thesis/3_code/4_DB project/PlatypusDB_dev_VK/data/Bcell_sequences_example_tree.rda")
file1 <- Bcell_sequences_example_tree

load("C:/Dokumente usw/Master/Reddy Lab/1_thesis/3_code/4_DB project/PlatypusDB_dev_VK/data/Bcell_tree_2.rda")
file2 <- Bcell_tree_2
```

```{r, eval = FALSE ,  warning=FALSE,message=FALSE}
library(ggplot2) 
library(scales)
library(gridExtra)
library(grid)
```

## 1. Introduction
AbNetForests is a novel computational framework, which provides a consesus on how to process high-throughtput scSeq data and integrate the high-dimensional feature space of gene expression to the evolution of B cells. It increases the size of the computational toolbox available to study immunoglobulin repertoires and incorporates additional features for the quantification of B cell clonal selection. Firstly, it can extract and organize B cell data directly from the output alignment of any single-cell technology. The generated data, containing information such as germline gene usage, full-length heavy and light chain sequence and CDR3 sequences can be combined with the transcriptional analysis of the gene expression libraries from the cellranger and subsequently B cells are grouped into clonal lineages, using one of the several clonotyping strategies that have been developed from Platypus (Yermanos et. al, 2021) under default parameters. The generated single-cell immune repertoire sequencing datasets can relate somatic hypermutation and evolution with transcriptional phenotypes. AbNetForests can additionally infer and visualize B cell mutational networks, modeling the extensive diversification of unique full-length variable heavy and variable light chain ($V_H$ + $V_L$) BCR sequences, integrating immune features such as antibody isotype or transcriptional cluster distribution and clonal expansion. In a last step, a qualitative and quantitative evaluation of the repertoire diversity takes place by computing both local and global summary statistics. Therefore, tree topologies and metrics are compared across one or several repertoires, disregarding whether they come from distinct individuals or organs.

An overview of the previously described workflow is demonstrated in Figure 1.

```{r, eval = FALSE ,  include=TRUE, fig.align="center", fig.cap=c("Flowchart summarizing the workflow of AbNetForests. The link with the R package Platypus (Yermanos et al. 2021) is also depicted."), echo=FALSE,out.width='0.75\\linewidth'}
knitr::include_graphics("general_sketch.pdf")
```

The user can set various parameters:

+ DAG (TRUE/FALSE): specifies whether a directed acyclic graph will is produced
+ clonal_frequency (TRUE/FALSE): specifies whether the labeling of vertices in graphs will be based on clonal frequency
+ scaleByClonalFreq (TRUE/FALSE): specifies whether vertex size will be scaled by clonal frequency of corresponding node
+ weight (TRUE/FALSE): specifies whether the weights of outgoing edges from Germline node will be set to 1 (FALSE) or elsewhere they will be set to the difference between the number of mutations among sequences in germline and connected nodes(value in the corresponding distance matrix) and the absolute value of the difference between the sequence lengths of germline and corresponding connected nodes
+ tie_flag ('rand', 'full', 'close_to_germ', 'far_from_germ', 'close_path_to_germ','far_path_from_germ',
'most_expanded','least_expanded'): 'rand' means random pruning 
in one of nodes, 'full' means keeping all nodes, close_to_germ means pruning of node(s) farthest from germline (based on number of intermediate nodes), 'far_from_germ' means pruning of node(s) closest to germline (based on number of intermediate nodes),'close_path_to_germ' means pruning of node(s) farthest from germline (based on edge path length), 'far_path_from_germ' meams pruning of node(s) closest to germline (based on edge path length),'most_expanded' means pruning of node(s) with the lowest B cell count(clonal frequency) and least_expanded, which means pruning of node(s) with the hightest B cell count(clonal frequency)
+ scaleBybetweenness (TRUE/FALSE): specifies whether the vertex size is scaled by the vertex betweenness centrality
+ scaleByclocloseness_metr (TRUE/FALSE): specifies whether vertex size is scaled by closeness centrality of vertices in graph
+ random.seed (interger): a random seed, specified by the user
+ alg_opt ('naive','two-step'): specifies the version of the edge selection algorithm that will be used in the construction of networks
+ cdr3 (0,1,NULL): specifies whether the user desires to select full length sequences (0) or CDR3 sequences (1) [only when the input is a list of csv files] and NULL otherwise


```{r, eval = FALSE ,  fig.show='hold'}

# Program parameters
DAG<-TRUE
clonal_frequency<-TRUE
scaleByClonalFreq<-TRUE
weight<-TRUE
tie_flag<-'rand'
scaleBybetweenness<-FALSE
scaleByclocloseness_metr<-FALSE
topdf<-TRUE
custom_mat<-NULL
random.seed<-3
alg_opt<-'naive'

```


When a user does not want to perform any prior filtering on the input data then he/she can conduct the following flow of commands. For the sake of the example, the isotype information is taken into account. Networks are depicted in tree format with the
reference germline set to the root. Nodes in each network are both labeled and scaled by the clonal frequency.

a) For the inference of networks:
```{r, eval = FALSE}

#"new" is an example dataset loaded with the package (See ABForests_sysdata)

graphs<-AbForests_AntibodyForest(new,FALSE,NULL,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt,NULL)

```

b) For the visualization of networks:
```{r, eval = FALSE , echo=T, results='hide'}

AbForests_PlotGraphs(graphs,NULL,topdf,"Networks")

```

A user may also modify the igraph object graphs himself/herself apart from using the PlotGraphs function of the package.

```{r, eval = FALSE}

igraph::plot.igraph(graphs[14][[1]]$network,vertex.label.cex=1+(0.01*graphs[14][[1]]$cells.per.variant),vertex.size=12+(1.2*graphs[14][[1]]$cells.per.variant))

legend(graphs[14][[1]]$legend[[1]],bty=graphs[14][[1]]$legend[[2]],legend=graphs[14][[1]]$legend[[3]],fill=graphs[14][[1]]$legend[[4]],border=graphs[14][[1]]$legend[[5]],inset=graphs[14][[1]]$legend[[6]],xpd=graphs[14][[1]]$legend[[7]],title=graphs[14][[1]]$legend$title,cex=graphs[14][[1]]$legend[[10]]*0.7)

```

c) For calculating metrics on networks:
```{r, eval = FALSE}

metrics<-AbForests_ForestMetrics(graphs,DAG,clonal_frequency,scaleByClonalFreq,weight,tie_flag,"isotype")

```

d) For visualizing a specific metric:
For example, we can inspect the shortest paths in each network (in position 6 of metrics list):
```{r, eval = FALSE , echo=T, results='hide'}

AbForests_PlotGraphs(metrics,6,topdf,"Metrics")

```

Similarly, we can infer the networks using the transcriptional cluster information.
```{r, eval = FALSE,  fig.show='hold',echo=T, results='hide'}

graphs_cluster<-AbForests_AntibodyForest(new,FALSE,NULL,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"cluster",random.seed,alg_opt,NULL)

```

```{r, eval = FALSE , echo=T, results='hide'}

AbForests_PlotGraphs(graphs_cluster,NULL,topdf,"Networks_cluster")

```

and modify the igraph object according to the user preferences. 
```{r, eval = FALSE}

igraph::plot.igraph(graphs_cluster[14][[1]]$network,vertex.label.cex=1+(0.01*graphs_cluster[14][[1]]$cells.per.variant),vertex.size=12+(1.2*graphs_cluster[14][[1]]$cells.per.variant))

legend(graphs_cluster[14][[1]]$legend[[1]],bty=graphs_cluster[14][[1]]$legend[[2]],legend=graphs_cluster[14][[1]]$legend[[3]],fill=graphs_cluster[14][[1]]$legend[[4]],border=graphs_cluster[14][[1]]$legend[[5]],inset=graphs_cluster[14][[1]]$legend[[6]],xpd=graphs_cluster[14][[1]]$legend[[7]],title=graphs_cluster[14][[1]]$legend$title,cex=graphs_cluster[14][[1]]$legend[[10]]*0.35)

```

The cluster "Unknown" indicates that the barcodes of cells are not included in the GEX library.

## 2. Dataset Format
To demonstrate the potential of AbNetForests, lineages were inferred using two previously described datasets following either chronic lymphocytic choriomeningitis virus (LCMV) infection or serial protein immunizations with Ovalbumin (Neumeier et al., 2021).

### Experimental dataset following LCMV infection 

The single-cell immune repertoire sequencing data from the bone marrow plasma cells of a mouse infected with high dose of LCMV ,from a recently published work (Neumeier et al., 2021), was used to investigate isotype-specific mutational signatures. This dataset was generated by performing single-cell immune repertoire sequencing of murine BM PCs 28 days following chronic LCMV infection. Bone marrow plasma cells were isolated via fluorescence-activated cell sorting (FACS) (CD138+, TACI+, CD19lo, B220lo), which was then used as input for single-cell immune repertoire sequencing using the 10X genomics 5’ V(D)J protocol. This experimental system recovers both gene expression and antibody repertoire sequencing data, relating clonal selection to cell phenotypes. B cells with identical heavy and light chain V and J germline genes, identical complementary determining region 3 sequence lengths for both heavy and light chain variable regions (CDRH3 for $V_H$ and CDRL3 for $V_L$) and at least 70% sequence homology in the CDR3 regions were grouped together into clonal lineages.The clonal lineage data was generated using the R package Platypus under default parameters (Yermanos et al. 2021).

The dataset consists of a list of repertoires, each consisting of clonal lineages, represented as data.frames, each of which is a 49-column structure.

A subset of a clonal lineage of the dataset is provided for guiding the user in constructing its own data input.

```{r, eval = FALSE ,  fig.show='hold'}
head(new[[1]],3)
```

For simplicity of the input, the package can receive a list of clonal lineages, each of which is a two-column structure:

+ Seq: full-length antibody sequences recovered from single cells after clonotyping
+ Name: isotype or/and transcriptional information for each single cell. The transcriptional clusters are supplied as numbers.The type of information (isotype or cluster), which is utilized in the analysis depends solely on the user’s purposes.

During each network reconstruction procedure, from a vast pool of roots produced as a result of V(D)J recombination, a reference germline sequence is added in each clonal lineage. This germline sequence is characterized by the largest occurrence from the set of reference germline heavy and light sequences for each particular clone from the 10x Genomics cellranger. 

### Experimental dataset following OVA infection 

The program is also capable of receiving input from a csv formatted file. Characteristic examples of such files are provided for the user’s convenience (Bcell_sequences_example_tree and Bcell_tree_2) and can assist in constructing its own data if he/she wants to diverge from the previously discussed structure. In such a case, column names can be modified, without altering the structure and the essence of data. These files contain 9 columns:

+ X: Enumeration of cells
+ HCvgene: The name of heavy chain v-gene segment
+ LCjgene: The name of light chain j-gene segment
+ HCjgene: The name of heavy chain j-gene segment
+ LCvgene: The name of light chain v-gene segment
+ HCcdr3: The CDR3 sequence in heavy chain
+ LCcdr3: The CDR3 sequence in light chain
+ Cluster: The transcriptional cluster in hexadecimal RGB color specification
+ HCisotype: The isotype information
+ HCLC: The full-length antibody sequences prior clonotyping

A subset of this dataset is provided for reference

```{r, eval = FALSE ,  fig.show='hold'}
file1<-data("Bcell_sequences_example_tree", package = "Platypus")
file1<-get(file1)
head(file1,3)
```

```{r, eval = FALSE,  fig.show='hold'}
file2<-data(Bcell_tree_2, package = "Platypus")
file2<-get(file2)
head(file2,3)
```

```{r, eval = FALSE ,  fig.show='hold'}
files<-c()
files<-append(files,file1)
files<-append(files,file2)
```

For the inference of networks, without modifying initial input data and using the full-length antibody sequences, we have 

```{r, eval = FALSE}
graphs_csv<-AbForests_AntibodyForest(files,TRUE,NULL,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt,0) 
```

```{r, eval = FALSE}
igraph::plot.igraph(graphs_csv[1][[1]]$network,vertex.label.cex=1+(0.01*graphs_csv[1][[1]]$cells.per.variant),vertex.size=8+(1.2*graphs_csv[1][[1]]$cells.per.variant))

legend(graphs_csv[1][[1]]$legend[[1]],bty=graphs_csv[1][[1]]$legend[[2]],legend=graphs_csv[1][[1]]$legend[[3]],fill=graphs_csv[1][[1]]$legend[[4]],border=graphs_csv[1][[1]]$legend[[5]],inset=graphs_csv[1][[1]]$legend[[6]],xpd=graphs_csv[1][[1]]$legend[[7]],title=graphs_csv[1][[1]]$legend$title,cex=graphs_csv[1][[1]]$legend[[10]]*0.7)
```

while when we consider only CDRH3 for $V_H$ and CDRL3 for $V_L$ sequences: 
```{r, eval = FALSE}

graphs_csv<-AbForests_AntibodyForest(files,TRUE,NULL,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt,1) 

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_csv[1][[1]]$network,vertex.label.cex=1+(0.01*graphs_csv[1][[1]]$cells.per.variant),vertex.size=8+(1.2*graphs_csv[1][[1]]$cells.per.variant))

legend(graphs_csv[1][[1]]$legend[[1]],bty=graphs_csv[1][[1]]$legend[[2]],legend=graphs_csv[1][[1]]$legend[[3]],fill=graphs_csv[1][[1]]$legend[[4]],border=graphs_csv[1][[1]]$legend[[5]],inset=graphs_csv[1][[1]]$legend[[6]],xpd=graphs_csv[1][[1]]$legend[[7]],title=graphs_csv[1][[1]]$legend$title,cex=graphs_csv[1][[1]]$legend[[10]]*0.7)

```

## 3. Data Summary Statistics
```{r, eval = FALSE ,  fig.show='hold'}

total_lineages<-length(new)
total_lineages

```

The mouse single-cell immune repertoire is composed of 1662 clonal lineages.
```{r, eval = FALSE}

df_total_lineages <- data.frame(total_lineages=total_lineages,colors=c('black'))
df_total_lineages$x_values <-c(rep("1",each=nrow(df_total_lineages)))
df_total_lineages$colors<-as.factor(df_total_lineages$colors)

p_total_lineages<-ggplot(df_total_lineages, aes(x = x_values, y =total_lineages ,fill=colors)) + ylab("Number of clonal lineages")+
 coord_cartesian() +
  scale_x_discrete(expand = expansion(add=c(0.6,0.5)))+
  scale_y_continuous(expand = c(0,0)) + 
  geom_bar(width=0.5,stat="identity", position="dodge",colour = "black",show.legend = FALSE)+
  theme(aspect.ratio =1,
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.length=unit(.3, "cm"),
        axis.title.y = element_text(size = rel(1), angle = 90),
        axis.text.y = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        axis.text = element_text(size = 8),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"))+
        scale_fill_manual(values = levels(df_total_lineages$colors))

p_total_lineages

```

```{r, eval = FALSE ,  fig.show='hold'}

bcells_per_clonal_lineage<-unname(unlist(sapply(new,function(z) nrow(z))))
df<-data.frame(Combinations=1:total_lineages, Freq=bcells_per_clonal_lineage)
p_cells_all<-ggplot(df,aes_string(x = 'Combinations', y = 'Freq')) + xlab("Clonal lineages") + ylab("Number of cells")+geom_bar(stat="identity", position="dodge",colour = "black",show.legend = FALSE)+
  coord_cartesian(expand = FALSE )+
  theme(aspect.ratio=1,axis.title.y = element_text(size = rel(1), angle = 90),
        axis.title.x = element_text(size = rel(1), angle = 0),
        axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.length=unit(.3, "cm"),
        axis.text = element_text(size = 8),
        axis.text.x = element_text(angle = 0, vjust = 0.5,colour = "black",face="bold"),
        axis.ticks.x = element_blank(),
        axis.text.y = element_text(angle = 0, vjust = 0.5,colour = "black",face="bold"),
        panel.background = element_blank(),legend.title=element_text(size=10,face="bold")) + scale_fill_discrete(name = "Vertex Degrees")

p_cells_all

```

```{r, eval = FALSE ,  fig.show='hold'}

mean_bcells_per_clonal_lineage<-round(mean(bcells_per_clonal_lineage))
mean_bcells_per_clonal_lineage

```

```{r, eval = FALSE ,  fig.show='hold'}

std_bcells_per_clonal_lineage<-round(sd(bcells_per_clonal_lineage))
std_bcells_per_clonal_lineage 

```

```{r, eval = FALSE ,  fig.show='hold'}

unique_Ab_variants_per_clonal_lineage<- AbForests_UniqueAntibodyVariants(new,"isotype",custom_mat,tie_flag,weight,random.seed,alg_opt,NULL)
df_t<-data.frame(Combinations=1:total_lineages, Freq=unique_Ab_variants_per_clonal_lineage)
p_variants_all<-ggplot(df_t,aes_string(x = 'Combinations', y = 'Freq')) + xlab("Clonal lineages") + ylab("Number of unique \n antibody variants")+geom_bar(stat="identity", position="dodge",colour = "black",show.legend = FALSE)+
  coord_cartesian(expand = FALSE )+
  theme(aspect.ratio=1,axis.title.y = element_text(size = rel(1), angle = 90),
        axis.title.x = element_text(size = rel(1), angle = 0),
        axis.text = element_text(size = 8),axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 0, vjust = 0.5,colour = "black",face="bold"),
        axis.ticks.x = element_blank(),
        axis.text.y = element_text(angle = 00, vjust = 0.5,colour = "black",face="bold"),
        panel.background = element_blank(),legend.title=element_text(size=10,face="bold")) + scale_fill_discrete(name = "Vertex Degrees")

```

```{r, eval = FALSE}

df_mean_cells_variants <- data.frame(Freq=c(bcells_per_clonal_lineage,unique_Ab_variants_per_clonal_lineage))
df_mean_cells_variants$sample_name <-c(rep("Cells",each=length(bcells_per_clonal_lineage)),rep("Variants",each=length(unique_Ab_variants_per_clonal_lineage)))
df_mean_cells_variants$colors <-as.vector(c(rep("black",each=length(bcells_per_clonal_lineage)),rep("gray85",each=length(unique_Ab_variants_per_clonal_lineage))))
df_mean_cells_variants$colors<-as.factor(df_mean_cells_variants$colors) 

p_mean_cells_variants<-ggplot(df_mean_cells_variants, aes(sample_name, Freq ,fill=colors)) + ylab("Number per clonal lineage")+ coord_cartesian() +
  geom_errorbar(stat = "summary", fun.data = "mean_se", 
                fun.args = list(mult = 1),
                position ="dodge", width = 0.2) +
  geom_bar(stat = "summary", fun = "mean", 
           position = position_dodge(width = 0.2), show.legend = FALSE) +
  scale_y_continuous(expand = c(0,0)) + 
  scale_x_discrete(name = "sample_name") + 
  theme(aspect.ratio = 1,axis.title.x=element_blank(),
    axis.title.y = element_text(size = rel(1), angle = 90),
    axis.text = element_text(size = 8),axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 0, vjust = 0.9,colour = "black",face="bold"),
        axis.ticks.x = element_blank(),
    axis.text.y = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        panel.background = element_blank(),legend.title=element_text(size=10,face="bold"))+scale_fill_manual(values = levels(df_mean_cells_variants$colors))

p_mean_cells_variants
```

```{r, eval = FALSE ,  fig.show='hold'}

mean_unique_Ab_variants_per_clonal_lineage<-round(mean(unique_Ab_variants_per_clonal_lineage))
mean_unique_Ab_variants_per_clonal_lineage 

```

```{r, eval = FALSE ,  fig.show='hold'}

std_unique_Ab_variants_per_clonal_lineage<-round(sd(unique_Ab_variants_per_clonal_lineage))
std_unique_Ab_variants_per_clonal_lineage 

```

Each clonal lineage has approximate on average 4 B cells and 3 clonal variants and considering standard deviation 11 B cells and 5 clonal variants.

From the iput list of clonal lineages, we can identify the clonal lineage, which contains the maximum number of cells:

```{r, eval = FALSE ,  fig.show='hold'}

pos<-which(bcells_per_clonal_lineage == max(bcells_per_clonal_lineage[bcells_per_clonal_lineage>0]))
head(new[[pos]],3)

```

And the clonal lineage, which contains the maximum number of unique antibody variants:
```{r, eval = FALSE ,  fig.show='hold'}

pos<-which(unique_Ab_variants_per_clonal_lineage == max(unique_Ab_variants_per_clonal_lineage[unique_Ab_variants_per_clonal_lineage>0]))
head(new[[pos]],3)

```

```{r, eval = FALSE, warning=FALSE}

p_total_lineages <- arrangeGrob(p_total_lineages, top = textGrob("A", x = unit(0, "npc"),y= unit(1, "npc"), just=c("left","top"),                                 gp=gpar(col="black", fontsize=12, fontfamily="Times")))

p_cells_all <- arrangeGrob(p_cells_all, top = textGrob("B", x = unit(0, "npc"), y = unit(1, "npc"), just=c("left","top"),
gp=gpar(col="black", fontsize=12, fontfamily="Times")))

p_variants_all <- arrangeGrob(p_variants_all, top = textGrob("C", x = unit(0, "npc"),y  = unit(1, "npc"), just=c("left","top"),
gp=gpar(col="black", fontsize=12, fontfamily="Times")))

p_mean_cells_variants <- arrangeGrob(p_mean_cells_variants, top = textGrob("D", x = unit(0, "npc"), y = unit(1, "npc"), just=c("left","top"),gp=gpar(col="black",fontsize=12, fontfamily="Times")))

grid.arrange(p_total_lineages,p_cells_all,
            p_variants_all,p_mean_cells_variants,
            ncol=2)

```

## 4. Sub-repertoire analysis

To determine whether the evolution of IgG, IgA and IgM clonal lineages underwent distinct selection processes, we classified B cell lineages by majority isotype, defined as the isotype per clonal lineage with the highest number of distinct cell barcodes.

The clonal lineages can be split into 5 subrepertoires. Each subrepertoire is dominated by the following isotypes: IgG, IgA, IgM and other types.

+ In case, there is an equal number of IgA and IgG isotypes in a clonal lineage, a separate category is created
+ In case there exists a tie in the number of IgA and IgM isotypes in a clonal lineage, this lineage is considered as IgA majority isotype
+ In case there exists a tie in the number of IgG and IgM isotypes in a clonal lineage, this lineage is considered as IgG majority isotype

SubRepertoiresByCells function assigns clonal lineages into sub-repertoires by isotype based on number of B cells.

```{r, eval = FALSE ,  fig.show='hold'}

repert<- AbForests_SubRepertoiresByCells(new)

```

The isotype distinction that we assumed is based on the immunological background of the different isotypes. In particular, IgG isotype is the most abundant antibody in the serum and together with IgA isotype are expressed via class switching after antigen challenge. IgM isotype is expressed on naive cells, is present early in the B cell response and is highly reactive to various antigens, without assistance from T cells.

```{r, eval = FALSE ,  fig.show='hold'}

total_lineages_per_isotype<-unlist(lapply(repert, function(x) length(x)))
total_lineages_per_isotype

```

This sub-categorization resulted in 1140 IgG majority clonal lineages, 163 IgA majority clonal lineages and 330 IgM majority clonal lineages. 

```{r, eval = FALSE}

df_clon_lineages_isotype <- data.frame(Strategies= c("IgG","IgA","IgM"),Freq=unname(total_lineages_per_isotype[1:3]),colors=c("green1","red","purple"))
df_clon_lineages_isotype$colors<-as.factor(df_clon_lineages_isotype$colors)

p_clon_lineages_isotype<-ggplot(df_clon_lineages_isotype, aes_string(x = 'Strategies', y = 'Freq', fill='colors')) + ylab("# of clonal lineages \n before filetering")+ 
  geom_bar(width=0.6,stat="identity", position="dodge",colour = "black",show.legend = FALSE)+
  coord_cartesian()+
  scale_x_discrete(expand = expansion(add=c(0.6,0.5)))+
  scale_y_continuous(expand = c(0,0)) +  
  theme(aspect.ratio = 1,axis.title.x=element_blank(),
        axis.title.y = element_text(size = rel(1), angle = 90),
        axis.text = element_text(size = 8),axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        axis.text.y = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        panel.background = element_blank(),legend.title=element_text(size=8,face="bold"))+scale_fill_manual(values = levels(df_clon_lineages_isotype$colors))

```

```{r, eval = FALSE}

list6<-AbForests_ConvertStructure(repert,"isotype",NULL)
rev_rep<-AbForests_RemoveNets(list6,"isotype",custom_mat,tie_flag,weight,NULL,6,random.seed,alg_opt)
remained_lineages_per_isotype<-unlist(lapply(rev_rep, function(x) length(x)))
remained_lineages_per_isotype

```

After eliminating the lineages with less than 6 unique cells, only 222, 23 and 30 clonal lineages remained in each of IgG, IgA
and IgM sub-repertoires. 

Prior to filtering, ConvertStructure function converts input data to the approriate format when the user desires to alter input data. Specifically, the function recovers the isotype/transcriptional cluster information and the full-length antibody sequences. 

The filtering of networks with less than 6 unique cells leads to
the elimination of those small networks which are less informative and convey a limited potential diversity in the structure of the network. On the other hand, the comparison
of multiple identical sized networks consisting of few nodes, allows to extract identical properties among those networks such as path lengths. A valid threshold value in the filtering is often less clear to determine, but increasing the lower bound
on the number of unique sequences within a clone increases exponentially the number of distinct possible graph topologies and therefore the likelihood of recognizing meaningful patterns in the graphs.

```{r, eval = FALSE}

df_clon_lineages_isotype_after <- data.frame(Strategies=c("IgG","IgA","IgM"), Freq=unname(remained_lineages_per_isotype[1:3]),colors=c("green1","red","purple"))
df_clon_lineages_isotype_after$colors <- as.factor(df_clon_lineages_isotype_after$colors)

p_clon_lineages_isotype_after<-ggplot(df_clon_lineages_isotype_after, aes_string(x = 'Strategies', y = 'Freq',fill='colors')) + ylab("# of clonal lineages \n after filtering")+ 
  geom_bar(width=0.6,stat="identity", position="dodge",colour = "black",show.legend = FALSE)+
  coord_cartesian()+
  scale_x_discrete(expand = expansion(add=c(0.6,0.5)))+
  scale_y_continuous(expand = c(0,0)) + 
  theme(aspect.ratio=1, axis.title.x=element_blank(),
        axis.title.y = element_text(size = rel(1), angle = 90),
        axis.text = element_text(size = 8),axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        axis.text.y = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        panel.background = element_blank(),legend.title=element_text(size=8,face="bold"))+scale_fill_manual(values = levels(df_clon_lineages_isotype_after$colors))

```

```{r, eval = FALSE}

percent_remained<-unlist(mapply("/",remained_lineages_per_isotype[1:3],total_lineages_per_isotype[1:3],SIMPLIFY = FALSE))

df_percent_remained <- data.frame(Strategies=c("IgG","IgA","IgM"),Freq=unlist(unname(percent_remained)),colors=c("green1","red","purple"))

df_percent_remained[] <- lapply(df_percent_remained, function(x) if(is.numeric(x)) x*100 else x)
df_percent_remained$colors <- factor(df_percent_remained$colors, levels = df_percent_remained$colors)
p_rem<-ggplot(df_percent_remained, aes(x = Strategies, y = Freq, fill= colors)) + ylab("% of clonal lineages \n after filtering")+
  geom_bar(width=0.5,stat="identity", position="dodge",colour = "black",show.legend = FALSE)+
  coord_cartesian()+
  scale_x_discrete(expand = expansion(add=c(0.6,0.5)))+
  scale_y_continuous(expand = c(0,0)) + 
  theme(aspect.ratio=1,axis.line = element_line(colour = "black"),
        axis.title.x=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.title.y = element_text(size = rel(1), angle = 90),
        axis.text.y = element_text(angle = 0, vjust = 0.8,colour = "black",face="bold"),
        axis.text = element_text(size = 8),
        axis.text.x = element_text(angle = 0, vjust = 0.5,colour = "black",face="bold"),
        panel.background = element_blank(),legend.title=element_text(size=8,face="bold")) + scale_fill_manual(values = levels(df_percent_remained$colors))

```

### Sub-repertoire Statistics

The subrepertoires statistics are summarized below.

```{r, eval = FALSE, warning=FALSE}

p_clon_lineages_isotype <- arrangeGrob(p_clon_lineages_isotype, top = textGrob("A", x = unit(0, "npc"), y = unit(1, "npc"), just=c("left","top"),gp=gpar(col="black", fontsize=12, fontfamily="Times")))

p_clon_lineages_isotype_after <- arrangeGrob(p_clon_lineages_isotype_after, top = textGrob("B", x = unit(0, "npc"), y = unit(1, "npc"), just=c("left","top"), gp=gpar(col="black",fontsize=12, fontfamily="Times")))

p_rem <- arrangeGrob(p_rem, top = textGrob("C", x = unit(0, "npc")
, y = unit(1, "npc"), just=c("left","top"),  gp=gpar(col="black",    fontsize=12, fontfamily="Times")))

grid.arrange(p_clon_lineages_isotype,
            p_clon_lineages_isotype_after,p_rem, ncol=2)

```

Consequently, the categorization of most clonal lineages as IgG majority and the subsequent filtering of networks with less than 6 unique cells, elevated the number of clonal variants in each network only in the IgG and IgA lineages. We were therefore able to demonstrate that class-switched B cells clones underwent further diversification of their unique BCR sequences.

## 5. Network inference

Within a single repertoire, there exists a multitude of co-evolving clonal lineages, each of which consists of B cells descending from an independent V(D)J recombination event and can therefore be modeled into a single network. Each network represents the evolutionary trajectory following somatic
hypermutation relative to an unmutated, reference germline. Vertices refer to unique appended full-length variable heavy and variable light chain ($V_H$ + $V_L$) antibody sequences, which can be either internal or terminal nodes in the network, thereby
diverging from the traditional B cell phylogenies. Edges connect clonal variants with the smallest separation similarity, computed
by the edit distance under default parameters. The reconstruction of networks is based on 2 node and edge selection algorithms , which maintain the principles of Directed Acyclic Graphs (DAGs), therefore eliminating potential bidirectional cycles.

### Naive Algorithm 

The default graph construction algorithm initially collapses unique antibody sequences, while preserving pivotal information on properties of the networks such as the clonal expansion of clonal variants, defined as the amount of cells corresponding to each unique antibody, the distribution of isotypes and the length of their antibody sequences. A symmetric distance matrix is then calculated, depicting the number of mutations between all unique antibody sequences and reference germline, within one clonal family. The default method to compute the distance matrix is the Levenshtein distance (Levenshtein, 1966), which counts the number of per letter transformations between strings to quantify their dissimilarity. Edge weights are extracted from the distance matrix apart from the special case of the unmutated germline. Weights of outgoing edges of germline nodes are either set to 1 (weight=FALSE) or to the difference between the corresponding distance from the matrix and the absolute value of the difference between the sequence lengths of germline and corresponding connected nodes (weight=TRUE).

Starting from the germline node, the closest sequences, according to distance matrix calculations, are assigned to the set of already examined nodes in the graph. For each element in the set of current nodes and for all combinations with the remaining nodes, edges with the minimum distance are sequentially added in the graph. This procedure is repeated until all nodes have been examined. Ties between distances are resolved randomly under default parameters, but additionally can be resolved using other immune repertoire features.

```{r, eval = FALSE}
graphs_IGHG<-AbForests_AntibodyForest(NULL,FALSE,rev_rep$list_IGHG,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt,NULL)
```

The AntibodyForest function apart from the construction of networks, provides essential information on the structure and properties of networks. Such information is summarized below.

+ graphs_IGHG$[[1][[1]]$ -> network: an igraph object, containing the first network in tree format

+ graphs_IGHG$[[1]][[2]]$ -> legend: contains the legend parameters of the first network

+ graphs_IGHG$[[1]][[3]]$ -> count.rand: contains the number of randomly considered nodes for the first network

+ graphs_IGHG$[[1]][[4]]$ -> adj.matrix: contains the adjacency matrix for the first network

+ graphs_IGHG$[[1]][[5]]$ -> distance.matrix: contains the distance matrix for the first network

+ graphs_IGHG$[[1]][[6]]$ -> cells.per.network: contains the number of cells for the first network

+ graphs_IGHG$[[1]][[7]]$ -> variants.per.network: contains the number of variants for the first network

+ graphs_IGHG$[[1]][[8]]$ -> variant.sequences: contains the sequences of the variants for the first network

+ graphs_IGHG$[[1]][[9]]$ -> cells.per.variant: contains the number of cells per variant (clonal frequency) for the first network

+ graphs_IGHG$[[1]][[10]]$ -> cell.indicies.per.variant:  the indices of cells per variant for the first network

+ graphs_IGHG$[[1]][[11]]$ -> new.variant.names: contains the names of variants for the first network

+ graphs_IGHG$[[1]][[12]]$ -> germline.index: contains the index of germline sequence for the first network

+ graphs_IGHG$[[1]][[13]]$ -> isotype.per.variant: contains the isotypes corresponding to each variant for the first network

+ graphs_IGHG$[[1]][[14]]$ -> transcriptome.cluster.per.variant: contains the transcriptional clusters corresponding to each variant for the first network

+ graphs_IGHG$[[1]][[15]]$ -> isotype.per.cell: contains the isotype corresponding to each cell for the first network

+ graphs_IGHG$[[1]][[16]]$ -> transcriptome.cluster.per.cell: contains the transcriptional cluster corresponding to each cell for the first network

Example networks are provided, highlighting the complexity of the LCVM dataset. Nodes are both labeled and scaled by the clonal frequency. The scaling of nodes by their relative clonal expansion assists in pinpointing identical antibody sequences produced by multiple B cells.

a) This is an example network from the IgG-sub-repertoire that contains highly clonally expanded variants.

```{r, eval = FALSE}

igraph::plot.igraph(graphs_IGHG[11][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHG[11][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHG[11][[1]]$network)$size),layout=0.05*graphs_IGHG[11][[1]]$network$layout)
legend(graphs_IGHG[11][[1]]$legend[[1]],bty = graphs_IGHG[11][[1]]$legend[[2]],legend=graphs_IGHG[11][[1]]$legend[[3]],fill=graphs_IGHG[11][[1]]$legend[[4]],border=graphs_IGHG[11][[1]]$legend[[5]],inset=graphs_IGHG[11][[1]]$legend[[6]],xpd=graphs_IGHG[11][[1]]$legend[[7]],title=graphs_IGHG[11][[1]]$legend$title,cex=graphs_IGHG[11][[1]]$legend[[10]]*0.7)

```

b) This is an example network from the IgG-sub-repertoire that contains multiple dictinct isotypes.

```{r, eval = FALSE}

igraph::plot.igraph(graphs_IGHG[104][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHG[104][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHG[104][[1]]$network)$size),layout=0.05*graphs_IGHG[104][[1]]$network$layout)
legend(graphs_IGHG[104][[1]]$legend[[1]],bty = graphs_IGHG[104][[1]]$legend[[2]],legend=graphs_IGHG[104][[1]]$legend[[3]],fill=graphs_IGHG[104][[1]]$legend[[4]],border=graphs_IGHG[104][[1]]$legend[[5]],inset=graphs_IGHG[104][[1]]$legend[[6]],xpd=graphs_IGHG[104][[1]]$legend[[7]],title=graphs_IGHG[104][[1]]$legend$title,cex=graphs_IGHG[104][[1]]$legend[[10]]*0.7)

```

c) This is an example network from the IgM-sub-repertoire that contains highly clonally expanded variants.

```{r, eval = FALSE}

graphs_IGHM<-AbForests_AntibodyForest(NULL,FALSE,rev_rep$list_IGHM,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt,NULL)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_IGHM[1][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHM[1][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHM[1][[1]]$network)$size),layout=0.05*graphs_IGHM[1][[1]]$network$layout)
legend(graphs_IGHM[1][[1]]$legend[[1]],bty = graphs_IGHM[1][[1]]$legend[[2]],legend=graphs_IGHM[1][[1]]$legend[[3]],fill=graphs_IGHM[1][[1]]$legend[[4]],border=graphs_IGHM[1][[1]]$legend[[5]],inset=graphs_IGHM[1][[1]]$legend[[6]],xpd=graphs_IGHM[1][[1]]$legend[[7]],title=graphs_IGHM[1][[1]]$legend$title,cex=graphs_IGHM[1][[1]]$legend[[10]]*0.7)

```

The package provides additional scaling and labeling options of nodes.

Relating the size of nodes with centrality metrics highlights the importance of certain nodes in the network. The measurement of node importance is of great practical and theoretical significance in identifying how individual nodes influence network structure and functionality, thereby describing the robustness of the network.

Therefore, the size of vertices can also depend on vertex betweenness (computed by counting the number of shortest paths going through a vertex (Freeman, 1979)) and vertex closeness (measured by the number of shortest paths going through each edge (Freeman, 1979)). 

Node labeling can be also based on the traversal order of nodes specified by the utilized algorithm. This option facilitates the the detection of modifications in the topology of networks. 

```{r, eval = FALSE}
#Scaling of nodes by vertex betweenness and labeling based on traversal order of nodes in the naive algorithm 
graphs_IGHM_new<-AbForests_AntibodyForest(NULL,FALSE,rev_rep$list_IGHM,custom_mat,clonal_frequency=FALSE,scaleByClonalFreq=FALSE,weight,tie_flag,scaleBybetweenness=TRUE,scaleByclocloseness_metr=FALSE,"isotype",random.seed,alg_opt,NULL)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_IGHM_new[1][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHM_new[1][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHM_new[1][[1]]$network)$size),layout=0.05*graphs_IGHM_new[1][[1]]$network$layout)
legend(graphs_IGHM_new[1][[1]]$legend[[1]],bty = graphs_IGHM_new[1][[1]]$legend[[2]],legend=graphs_IGHM_new[1][[1]]$legend[[3]],fill=graphs_IGHM_new[1][[1]]$legend[[4]],border=graphs_IGHM_new[1][[1]]$legend[[5]],inset=graphs_IGHM_new[1][[1]]$legend[[6]],xpd=graphs_IGHM_new[1][[1]]$legend[[7]],title=graphs_IGHM_new[1][[1]]$legend$title,cex=graphs_IGHM_new[1][[1]]$legend[[10]]*0.7)

```

### Two-step Algorithm

The two-step algorithm relies on the same concept, but completes the network construction in a multi-level fashion. Resolving ties in the distance matrix is handled in a second step. Edges rendering nodes with multiple parents are eliminated,
forcing each antibody variant to descend from a single parent. Consequently, AbNetForests supports various customizable options that enable the user to select whether mutational load, clonal expansion, random selection or no selection at all dictates graph topology. In case of subsequent ties, a random node is selected.

1. "rand" option allows the random selection of one child node
2. "full" option allows keeping all children nodes
3. "close_to_germ" and "far_from_germ" options allow the pruning of farthest and closest nodes relative to the germline, respectively, based on the number of intermediate nodes in the path.
4. "close_path_to_germ" and "far_path_from_germ" options allow the pruning of farthest and closest nodes relative to the germline, respectively, based on the weighted or unweighted edge path length.
5. "most_expanded" and "least_expanded" options allow the pruning of nodes with the lowest B cell count and the highest B cell count, respectively.

Tie resolving options 3 and 4 are utilized to incorporate information regarding deep (a single variant continues to
linearly produce new progeny) versus broad (a single variant produces multiple direct progeny) selection, while option 5 resolves ties by assuming that either the most expanded or least expanded clones contribute to new variants. Closeness of a node to germline node, as described in tie case 3, means identifying the minimum number of edges in the path between the node and germline, whereas in tie case 4 the minimum weighted path length between the node and germline.

Therefore, using the 2-step algorithm and preserving the option to resolve ties randomly influnces the topology of networks 

```{r, eval = FALSE}

graphs_IGHG_2<-AbForests_AntibodyForest(NULL,FALSE,rev_rep$list_IGHG,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt="two-step",NULL)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_IGHG_2[104][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHG_2[104][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHG_2[104][[1]]$network)$size),layout=0.05*graphs_IGHG_2[104][[1]]$network$layout)
legend(graphs_IGHG_2[104][[1]]$legend[[1]],bty = graphs_IGHG_2[104][[1]]$legend[[2]],legend=graphs_IGHG_2[104][[1]]$legend[[3]],fill=graphs_IGHG_2[104][[1]]$legend[[4]],border=graphs_IGHG_2[104][[1]]$legend[[5]],inset=graphs_IGHG_2[104][[1]]$legend[[6]],xpd=graphs_IGHG_2[104][[1]]$legend[[7]],title=graphs_IGHG_2[104][[1]]$legend$title,cex=graphs_IGHG_2[104][[1]]$legend[[10]]*0.7)

```

The graph topology can also be altered under different tie resolving cases. For example, changing the option to resolve ties by removing the farthest node(s) from germline ("close_to_germ") influnces the topology of networks: 

```{r, eval = FALSE}

graphs_IGHG_close_germ<-AbForests_AntibodyForest(NULL,FALSE,rev_rep$list_IGHG,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag="close_to_germ",scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt="two-step",NULL)

```

```{r, eval = FALSE}
igraph::plot.igraph(graphs_IGHG_close_germ[104][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHG_close_germ[104][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHG_close_germ[104][[1]]$network)$size),layout=0.05*graphs_IGHG_close_germ[104][[1]]$network$layout)
legend(graphs_IGHG_close_germ[104][[1]]$legend[[1]],bty = graphs_IGHG_close_germ[104][[1]]$legend[[2]],legend=graphs_IGHG_close_germ[104][[1]]$legend[[3]],fill=graphs_IGHG_close_germ[104][[1]]$legend[[4]],border=graphs_IGHG_close_germ[104][[1]]$legend[[5]],inset=graphs_IGHG_close_germ[104][[1]]$legend[[6]],xpd=graphs_IGHG_close_germ[104][[1]]$legend[[7]],title=graphs_IGHG_close_germ[104][[1]]$legend$title,cex=graphs_IGHG_close_germ[104][[1]]$legend[[10]]*0.7)
```

A user may does not want to add all these biases, thus the package can generate networks without resolving ties. These networks are not directed acyclic any more as they contain bi-directional cycles.

```{r, eval = FALSE}

graphs_IGHG_full<-AbForests_AntibodyForest(NULL,FALSE,rev_rep$list_IGHG,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag="full",scaleBybetweenness,scaleByclocloseness_metr,"isotype",random.seed,alg_opt="two-step",NULL)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_IGHG_full[104][[1]]$network,vertex.label.cex=1+(0.0001*graphs_IGHG_full[104][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_IGHG_full[104][[1]]$network)$size),layout=0.05*graphs_IGHG_full[104][[1]]$network$layout)
legend(graphs_IGHG_full[104][[1]]$legend[[1]],bty = graphs_IGHG_full[104][[1]]$legend[[2]],legend=graphs_IGHG_full[104][[1]]$legend[[3]],fill=graphs_IGHG_full[104][[1]]$legend[[4]],border=graphs_IGHG_full[104][[1]]$legend[[5]],inset=graphs_IGHG_full[104][[1]]$legend[[6]],xpd=graphs_IGHG_full[104][[1]]$legend[[7]],title=graphs_IGHG_full[104][[1]]$legend$title,cex=graphs_IGHG_full[104][[1]]$legend[[10]]*0.7)

```

## 6. Calculation of network metrics 

Following the construction of the mutational networks, AbNetForests calculates and visualizes summary statistics, which provides the opportunity for both qualitative and quantitative comparison of the evolutionary relationships among antibodies. The tool extracts the topologies of individual networks within the repertoire and links them with clonal expansion, distance from the reference germline, isotype distribution and
transcriptional phenotype. Specifically, the following metrics are computed for all networks:

1. weighted/unweighted longest path(s) from germline. Longest path is defined as the path with the maximum length between all shortest paths from the germline node to all other nodes. Shortest path is a path with the minimal number of edges. In case of unweighted graphs, the breadth-first search algorithm is used, while for weighted graphs Dijkstra's algorithm is utilized
2. length of weighted/ unweighted longest shortest path from germline
3. average/standard deviation/minimum/maximum number of daughter cells. These metrics are computed with the aid of the most fundamental graph property, the vertex degree, which is defined as the number of the adjacent edges of the node
4. weighted vertex degree or strength. It is calculated by summing up the edge weights of the adjacent edges for each vertex (Barrat et al., 2004)
5. average number of isotypes and/or clusters. For each network, the occurrences of distinct isotypes or clusters are counted and divided by the number of nodes
6. informative data.frame for isotypes and/or clusters, which contains the type of isotypes/clusters for each pair of nodes in the graph (Parent-Child relationship in the graph)
7. vertex betweenness centrality
8. edge betweenness centrality. It is measured by the number of shortest paths going through each edge (Freeman, 1979)
9. closeness centrality of vertices
10. global/average clustering coefficient. To compute clustering coefficients, transitivity is measured by specifying the probability of adjacent vertices of a vertex to be connected. Global transitivity is the ratio of triangles and connected triples in the graph, while local transitivity follows the same
definition but centered on the vertex level (for directed graphs, the direction of the edges is ignored)
11. mean clonal expansion. It is calculated as the mean value of clonal frequencies of all vertices in the network
12. ratios of number of edges from germline to each node divided by the respective clonal frequency of each node
13. mean ratio of the number of edges from germline to each node divided byclonal frequency (mean ratio of values in metric 12).
14. mean number of edges from germline for all nodes in the network
15. ratios of total path length from germline to each node divided by the respective clonal frequency of each node
16. mean ratio: total path length from germline to each node divided by the respective clonal frequency of each node (mean ratio of values in metric 15)
17. mean total path length from germline for all nodes in the network

The metrics for the IgG subrepertoire are summarized below

```{r, eval = FALSE}

metrics_igg<-AbForests_ForestMetrics(graphs_IGHG,DAG,clonal_frequency,scaleByClonalFreq,weight,tie_flag,"isotype")

metrics_igg[[1]]$`Mean Total path length from germline`

```

Another example metric is the distribution of distinct isotypes versus their frequency

```{r, eval = FALSE}
metrics_igg[[1]]$`Plot: Distribution of isotypes`
```

## 7. Comparison of networks

We can also compare the repertoires of distinct B cells. In this case, we compare the IgG and IgM subreperoires using the CompareForests function

```{r, eval = FALSE , echo=T, results='hide'}
output<-AbForests_CompareForests(graphs_IGHG,graphs_IGHM,DAG,clonal_frequency,scaleByClonalFreq,weight,tie_flag,"isotype")
```

CompareForests function has 3 outputs

+ combined_df, a data.frame that summarizes metrics for both repertoires. In particular, each row represents a single network and networks of both repertoires are combined row-wise. It has the following columns:

1. Weighted.Longest.path.from.germline
2. Length.of.weighted.longest.shortest.path.from.germline
3. Unweighted.Longest.path.from.germline
4. Length.of.unweighted.longest.shortest.path.from.germline
5. Average.number.of.daughter.cells
6. Std.number.of.daughter.cells
7. Min.number.of.daughter.cells
8. Max.number.of.daughter.cells
9. Weighted.vertex.degree
10. Average.number.of.clusters/isotypes
11. Isotypes/Clusters.info
12. vertex.betweenness.centrality
13. edge.betweenness.centrality
14. closeness.centrality.of.vertices
15. global.clustering.coefficient
16. average.clustering.coefficient
17. Mean.clonal.expansion

If the labeling or scaling of nodes in graph is based on clonal frequency (arguments: clonal_frequency==TRUE or scaleByClonalFreq==TRUE), then combined_df contains also:

18. Ratio.Number.of.edges.from.germline.to.each.node.with.clonal.frequency
19. Mean.Ratio.Number.of.edges.from.germline.to.each.node.with.clonal.frequency
20. Mean.number.of.edges.from.germline
21. Ratio.Total.path.length.from.germline.to.each.node.with.clonal.frequency
22. Mean.Ratio.Total.path.length.from.germline.to.each.node.with.clonal.frequency
23. Mean.Total.path.length.from.germline
24. Repertoire.id
25. Number.of.sequences

+ isotype_info_rep1, a data.frame that summarizes the isotype/cluster info for the IgG sub-repertoire
+ isotype_info_rep2, a data.frame that summarizes the isotype/cluster info for the IgM sub-repertoire

## 8. Custom node coloring

For visualization purposes only, AbNetForests can color network nodes not only based on isotype or transcriptional cluster information, but also based on any data column. This is achieved by allowing the user to specify the name of the column of interest. The possibility of custom coloring is supported for both possible input formats either as a list of dfs or a list of csv files.   

For the lcmv dataset, if we want to color nodes based on VDJ_jgene, then

```{r, eval = FALSE}

graphs_custom<-AbForests_AntibodyForest(new,FALSE,NULL,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"VDJ_jgene",random.seed,alg_opt,NULL)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_custom[14][[1]]$network,vertex.label.cex=1+(0.0001*graphs_custom[14][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_custom[14][[1]]$network)$size),layout=0.05*graphs_custom[14][[1]]$network$layout)
legend(graphs_custom[14][[1]]$legend[[1]],bty = graphs_custom[14][[1]]$legend[[2]],legend=graphs_custom[14][[1]]$legend[[3]],fill=graphs_custom[14][[1]]$legend[[4]],border=graphs_custom[14][[1]]$legend[[5]],inset=graphs_custom[14][[1]]$legend[[6]],xpd=graphs_custom[14][[1]]$legend[[7]],title=graphs_custom[14][[1]]$legend$title,cex=graphs_custom[14][[1]]$legend[[10]]*0.7)

```
 
For the csv files, we can color based on LCvgene

```{r, eval = FALSE}

graphs_csv<-AbForests_AntibodyForest(files,TRUE,NULL,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"LCvgene",random.seed,alg_opt,0)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_csv[1][[1]]$network,vertex.label.cex=1+(0.0001*graphs_csv[1][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_csv[1][[1]]$network)$size),layout=0.05*graphs_csv[1][[1]]$network$layout)
legend(graphs_csv[1][[1]]$legend[[1]],bty = graphs_csv[1][[1]]$legend[[2]],legend=graphs_csv[1][[1]]$legend[[3]],fill=graphs_csv[1][[1]]$legend[[4]],border=graphs_csv[1][[1]]$legend[[5]],inset=graphs_csv[1][[1]]$legend[[6]],xpd=graphs_csv[1][[1]]$legend[[7]],title=graphs_csv[1][[1]]$legend$title,cex=graphs_csv[1][[1]]$legend[[10]]*0.7)

```

## 9. Other package functionality

In case the user wants to perform changes in the input data, for a list of csvs as input, similar to the provided data, the CsvToDf function is first used to transform the input list to a list of data.frames, with the appropriate format.

In addition, there is the option to split a single cell immune repertoire into sub-repertoires by isotype based on the number of unique sequences instead of the number of B cells, using the SubRepertoiresByUniqueSeq function.

```{r, eval = FALSE}
repert<-AbForests_SubRepertoiresByUniqueSeq(new,"isotype",custom_mat,tie_flag,weight,random.seed,alg_opt,0)
```

We can also filter those networks with less than N unique sequences apart from the elimination of networks with less than C unique cells.

In PlotGraphs function, parameter topdf=FALSE would enable the user to print the network in the console (This parameter option is not advised for large input lists). 

The previously additional functionality of the package is summarized below, taking into account the transcriptional cluster information and removing the networks with less than 4 unique BCR sequences.

```{r, eval = FALSE}

list_scv<-AbForests_CsvToDf(files) 
list6<-AbForests_ConvertStructure(list_scv,"cluster",0)
rev_rep<-AbForests_RemoveNets(list6,"cluster",custom_mat,tie_flag,weight,4,NULL,random.seed,alg_opt)
graphs_csv_less_4<-AbForests_AntibodyForest(NULL,FALSE,rev_rep,custom_mat,clonal_frequency,scaleByClonalFreq,weight,tie_flag,scaleBybetweenness,scaleByclocloseness_metr,"cluster",random.seed,alg_opt,0)

```

```{r, eval = FALSE}

igraph::plot.igraph(graphs_csv_less_4[1][[1]]$network,vertex.label.cex=1+(0.0001*graphs_csv_less_4[1][[1]]$cells.per.variant),vertex.size=17+(0.8*igraph::V(graphs_csv_less_4[1][[1]]$network)$size),layout=0.05*graphs_csv_less_4[1][[1]]$network$layout)
legend(graphs_csv_less_4[1][[1]]$legend[[1]],bty = graphs_csv_less_4[1][[1]]$legend[[2]],legend=graphs_csv_less_4[1][[1]]$legend[[3]],fill=graphs_csv_less_4[1][[1]]$legend[[4]],border=graphs_csv_less_4[1][[1]]$legend[[5]],inset=graphs_csv_less_4[1][[1]]$legend[[6]],xpd=graphs_csv_less_4[1][[1]]$legend[[7]],title=graphs_csv_less_4[1][[1]]$legend$title,cex=graphs_csv_less_4[1][[1]]$legend[[10]]*0.26)

```

## 10. Custom distance matrix

AbNetForests allows the investigation of other mutational models, more appropriate for antibodies, apart from the previously considered one, receiving as input a custom distance matrix per each network. The user is responsible for providing a distance matrix with the appropriate dimensions. 

## 11. Converting phylogenetic tree to custom distance matrix

Finally, there is the option to convert a previously existing phylogenetic tree to a corresonding distance matrix, utilizing the cophenetic distance.

Given an example phylogenetic tree in Newick format, we can extract the distance matrix

```{r, eval = FALSE}

AbForests_PlyloToMatrix("example.tree")

```

## 10. References

+ "Platypus: an open-access software for integrating lymphocyte single-cell immune repertoires with transcriptomes"
Yermanos, Alexander; Agrafiotis, Andreas; Kuhn, Raphael; Robbiani, Damiano; Yates, Josephine; Papadopoulou, Chrysa; Han, Jiami; Sandu, Ioana; Weber, Cédric; Bieberich, Florian; Vazquez-Lombardi,
Rodrigo; Neumeier, Daniel ; Oxenius, Annette; Reddy, Sai(2021).
https://doi.org/10.1093/nargab/lqab023

+ "Single-cell sequencing reveals clonally expanded plasma cells during chronic viral infection produce virus-specific and cross-reactive antibodies.Neumeier Daniel, Pedrioli Alessandro, Genovese Alessandro, Sandu Ioana, Ehling Roy, Hong Kai-Lin, Papadopoulou Chrysa, Agrafiotis Andreas, Kuhn Raphael, Robbiani Damiano, Han Jiami, Hauri Laura, Csepregi Lucia, Greiff Victor, ,Merkler Doron, Reddy Sai, Oxenius Annette, Yermanos Alexander (2021). 
bioRxiv doi: https://doi.org/10.1101/2021.01.29.428852

+ Levenshtein, V. (1966) Binary Codes capable of correcting deletions, insertions, and reversals. Solviet Physics Doklady 10 (8): 707-710

+ Freeman, L.C. (1979). Centrality in Social Networks I: Conceptual Clarification. Social Networks, 1, 215-239.

+ Barrat Alain, Barthelemy Marc, Pastor-Satorras Romualdo, Vespignani Alessandro. (2004). The architecture of complex weighted networks. Proc. Natl. Acad. Sci. USA 101, 3747.
