<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Alexander Yermanos, Victor Kreiner, Andreas Agrafiotis, Tudor-Stefan Cotet" />

<meta name="date" content="2022-08-07" />

<title>PlatypusV3 AgedCNS vignette</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap;
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #d14; }
code > span.fl { color: #d14; }
code > span.ch { color: #d14; }
code > span.st { color: #d14; }
code > span.co { color: #888888; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #900; font-weight: bold; }
code > span.er { color: #a61717; background-color: #e3d2d2; }
</style>




</head>

<body>




<h1 class="title toc-ignore">PlatypusV3 AgedCNS vignette</h1>
<h4 class="author">Alexander Yermanos, Victor Kreiner, Andreas
Agrafiotis, Tudor-Stefan Cotet</h4>
<h4 class="date">2022-08-07</h4>



<div id="introduction" class="section level2">
<h2>1. Introduction</h2>
<p>Platypus is a package designed to facilitate the analysis of
single-cell immune repertoire sequencing experiments. The package can be
used to separately analyze gene expression (GEX) or immune receptor
repertoire (VDJ) sequencing data, in addition to integrating the two
data sets to combine phenotypic features with repertoire analysis. The
package is designed to primarily analyze the output from 10x genomics
cellranger (output from count for GEX and VDJ for enriched immune
receptor libraries). The functions could work with other barcode-based
scSeq technologies assuming the input columns are added correctly. The
gene expression analysis relies heavily upon Seurat, a commonly used R
package for single-cell sequencing (scSeq). The core software can be
found at <a href="https://github.com/alexyermanos/Platypus" class="uri">https://github.com/alexyermanos/Platypus</a> and examples of
use can be found in the publication <a href="https://doi.org/10.1093/nargab/lqab023" class="uri">https://doi.org/10.1093/nargab/lqab023</a></p>
<p>Current functions in development can be found at the functions branch
of the github <a href="https://github.com/alexyermanos/Platypus/tree/master/R" class="uri">https://github.com/alexyermanos/Platypus/tree/master/R</a></p>
</div>
<div id="installation-platypus-v3.1" class="section level2">
<h2>2. Installation (Platypus v3.1)</h2>
<p>Due to the recent changes of the default clonotyping strategy in
Cellranger (version 5 and version 6) we are currently rebuilding v3 of
Platypus to revolve around the VDJ_GEX_matrix function (vgm for short).
This function integrates both repertoire and transcriptome information
and will serve as the input to all secondary functions in future
iterations of the package. The advantage of this is having all
repertoire and transcriptome information at a per-cell level.</p>
<p>The change in clonotyping can be found here - <a href="https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/algorithms/clonotyping" class="uri">https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/algorithms/clonotyping</a></p>
<p>The VDJ_GEX_matrix function will soon be found in the newest version
of the R package (v3.0) with special thanks to Victor Kreiner. The
current functions and documentation can be found already at <a href="https://github.com/alexyermanos/Platypus/tree/master/R/VDJ_GEX_matrix.R" class="uri">https://github.com/alexyermanos/Platypus/tree/master/R/VDJ_GEX_matrix.R</a>
All other functions are already or in the process of being updated. A
function which is available for V3 as a new parameter “platypus.version”
which can be set to either “v2”, for backcompatibility or “v3”. Some new
functions are only compatible with “v3”</p>
<p>Can stay tuned for updates <a href="https://twitter.com/alexyermanos" class="uri">https://twitter.com/alexyermanos</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Removing any previous versions of the package</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#First can ensure that there is no previous version installed locally</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#detach(&quot;package:Platypus&quot;, unload=TRUE)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#remove.packages(&quot;Platypus&quot;)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="do">### Packages most frequently imported</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;Tidyverse&quot;)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;Biostrings&quot;)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;jsonlite&quot;)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;seqinr&quot;)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;Seurat&quot;)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="do">### Downloading and installing Platypus</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># First we need to download the most recent version from the master branch at https://github.com/alexyermanos/Platypus we can install the package using the following command. </span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">WARNING</span><span class="co">: This needs to be replaced with your own directory where the downloaded package is found</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># For MacOS users it may look like this</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;~/Downloads/Platypus_3.1.tar.gz&quot;, repos = NULL, type=&quot;source&quot;)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># For windows it will likely look something like this. </span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">WARNING</span><span class="co">: You will need to replace &#39;YourPCName&#39; with your user name for the windows account in the directory. </span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages(&quot;C:/Users/YourPCName/Downloads/Platypus_3.1.tar.gz&quot;, repos = NULL, type=&quot;source&quot;)</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Now we can load the installed package into the R environment. In case of problems with installing other R packages that are used in Platypus, please see the README file at the https://github.com/alexyermanos/Platypus, where we outline how to install the other R packages for both Windows and MacOS.</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Platypus)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co"># The individual R functions can additionally be found on the github in the Functions branch. Within this branch, there is a folder &quot;R&quot; which contains the individual functions. This can similarly be downloaded and loaded into the R environment in case not all functions are desired. These functions are actively updated and may include more features than the in original tar.gz file. </span></span></code></pre></div>
</div>
<div id="extracting-and-integrating-repertoire-data-with-vdj_gex_matrix-platypus-v3" class="section level2">
<h2>3. Extracting and integrating repertoire data with VDJ_GEX_matrix
(Platypus v3)</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Downloading the test data for VDJ_GEX_matrix </span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># While the Platypus manuscript uses the COVID-19 data, the vignette for Platypus v3 will use the data from murine B cells in the aged CNS, which can be found at the following link https://polybox.ethz.ch/index.php/s/fxQJ3NrRSwiPSSo This small dataset contains VDJ (separate libraries for B) and GEX libraries from the central nervous system of two murine samples. More information can be found https://doi.org/10.1098/rspb.2020.2793</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># After downloading the zip file named &quot;Platypus_CNS_data.zip&quot;, please unzip the file and find the path to the newly formed folder. Typically this will be in the Downloads folder, so the code below should work on MacOS. For windows please uncomment the code and change the user name to match your PC.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>VDJ.out.directory.list <span class="ot">&lt;-</span> <span class="fu">list</span>() <span class="do">### Set directory to the outs folder of cellranger vdj</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>VDJ.out.directory.list[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;~/Downloads/Platypus_CNS_data/VDJ_S1/&quot;</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>VDJ.out.directory.list[[<span class="dv">2</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;~/Downloads/Platypus_CNS_data/VDJ_S2/&quot;</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>GEX.out.directory.list <span class="ot">&lt;-</span> <span class="fu">list</span>() <span class="do">### Set directory to the outs folder of cellranger count</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>GEX.out.directory.list[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;~/Downloads/Platypus_CNS_data/GEX_S1/&quot;</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>GEX.out.directory.list[[<span class="dv">2</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;~/Downloads/Platypus_CNS_data/GEX_S2/&quot;</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># For windows: </span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ.out.directory.list[[1]] &lt;- c(&quot;C:/Users/YourPCName/Downloads/PlatypusTestData/Patient1_GEX&quot;)</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ.out.directory.list[[2]] &lt;- c(&quot;C:/Users/YourPCName/Downloads/PlatypusTestData/Patient2_GEX&quot;)</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># We will call the output vgm (short for Vdj_Gex_Matrix) - this object can be supplied as input to downstream functions in v3 of the package.</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>vgm <span class="ot">&lt;-</span> <span class="fu">VDJ_GEX_matrix</span>(<span class="at">VDJ.out.directory.list =</span> VDJ.out.directory.list,</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                               <span class="at">GEX.out.directory.list =</span> GEX.out.directory.list,</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                               <span class="at">GEX.integrate =</span> T,</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                               <span class="at">VDJ.combine =</span> T,</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                               <span class="at">integrate.GEX.to.VDJ =</span> T,</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>                               <span class="at">integrate.VDJ.to.GEX =</span> T, <span class="co">#This will adjunct the VDJ information as metadata to the GEX object</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                               <span class="at">exclude.GEX.not.in.VDJ =</span> F,</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                               <span class="at">filter.overlapping.barcodes.GEX =</span> T,</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                               <span class="at">filter.overlapping.barcodes.VDJ =</span> T,</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                               <span class="at">exclude.on.cell.state.markers =</span> <span class="fu">c</span>(<span class="st">&quot;CD3E&quot;</span>), <span class="co">#Exclude T cells from this analysis</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                               <span class="at">get.VDJ.stats =</span> T,</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                               <span class="at">parallel.processing =</span> <span class="st">&quot;none&quot;</span>, <span class="co">#see note at the end of this chunk</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                               <span class="at">trim.and.align =</span> F, <span class="co">#Do not align BCR sequences to reference </span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                               <span class="at">group.id =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="do">## The output will be a list - </span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co"># vgm[[1]] corresponds to the VDJ master dataframe</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co"># vgm[[2]] corresponds to the GEX in the form of a seurat object</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co"># vgm[[3]] corresponds to the output of VDJ_stats subfunction - which provides information about the number of chains, sequencing reads, etc</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="co"># vgm[[4]] holds the input parameters </span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co"># vgm[[5]] holds the sessionInfo output at the time of function call</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="do">## Setting trim.and.align to TRUE will provide full-length VDJ and VJ sequences but also increase run time significantly. Alignment is done via Biostrings::pairwiseAlignment(). Gap opening and extension costs can be adapted</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="do">## This function can similarly be used when only VDJ or GEX data is present. Simply do only provide the path list of either GEX or VDJ</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co"># VDJ_comb_gex &lt;- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co">#                                GEX.integrate = F,</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="co">#                                VDJ.combine = T,</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co">#                                integrate.GEX.to.VDJ = F,</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="co">#                                integrate.VDJ.to.GEX = F,</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="co">#                                exclude.GEX.not.in.VDJ = F,</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co">#                                filter.overlapping.barcodes.GEX = F,</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="co">#                                filter.overlapping.barcodes.VDJ = F,</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="co">#                                get.VDJ.stats = F,</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co">#                                parallel.processing = &quot;none&quot;,</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="co">#                                trim.and.align = T,</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="co">#                                gap.opening.cost = 10,</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="co">#                                gap.extension.cost = 4</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="co">#                                group.id = c(1,2))</span></span></code></pre></div>
<p>Note on parallel processing: Parallel processing is provided by the
Parallel package via parlapply (for Windows) and mclapply (for MAC). We
reccomend using either options only &gt; 5000 cells. If your machine
does not support parallel processing e.g. for compatibility reasons,
parlapply may be slower than conventional lapply, which is used when
“none” is specified for the argument parallel.processing</p>
<p>We can briefly look at the datastructure</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">colnames</span>(vgm[[<span class="dv">1</span>]]))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="do">## By setting integrate.GEX.to.VDJ and integrate.VDJ.to.GEX to T, VDJ and GEX information will be found in vgm[[1]] and vgm[[2]] objects.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># For example, the seurat-determined cluster is attached to each cell in the VDJ library by</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>seurat_clusters)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># which corresponds to cells with the following VDJ_cdr3 </span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>VDJ_cdr3s_aa)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># an NA indicates that the cell barcode in the VDJ library was not detected in the GEX object (or was filtered out, depending on mitochondrial gene limits, etc)</span></span></code></pre></div>
<p>Importantly, all samples are integrated in one vgm. Basic stats can
be retrieved from the VDJ_GEX_stats output which was run as part of the
VGM function (get_VDJ_stats = T)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(vgm[[<span class="dv">3</span>]]) </span></code></pre></div>
<p>Moreover, given the many parameters of the VGM function is may be
useful to check back on runtime parameters. These, as well as session
info are also saved in the vgm object</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(vgm[[<span class="dv">4</span>]]) <span class="co">#Runtime params</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(vgm[[<span class="dv">5</span>]]) <span class="co">#session info</span></span></code></pre></div>
</div>
<div id="gene-expression-analysis-platypus-v3" class="section level2">
<h2>4. Gene expression analysis (Platypus v3)</h2>
<p>The vgm object now contains all information needed for both V(D)J and
gene expression analysis. In the examples below we first focus on gene
expression</p>
<p>We can visualize the 2D plots for each sample individually. By
default, UMAP, PCA, and TSNE embeddings are included in the object. Here
it is important to supply the seurat object in vgm[[2]]. For the
parameter group.by we supply “sample_id” to color points by the entry in
their sample id column</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># In Platypus version 2, the output from GEX_automate was used as input to other GEX functions. These functions are still compatible with v3 if the vgm[[2]] seurat object is supplied as input.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># For example, the following function can be used to calculate the DE genes for each cluster, as before. </span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;sample_id&quot;</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;pca&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;sample_id&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;tsne&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;sample_id&quot;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">#alternatively plot each sample separately</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">split.by =</span> <span class="st">&quot;sample_id&quot;</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">#this also works with any other column of vgm[[2]]@meta.data</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">split.by =</span> <span class="st">&quot;group_id&quot;</span>)</span></code></pre></div>
<p>We can observe that the majority of clusters have cells from both
samples, suggesting a similar distribution of transcriptional properties
between the two samples. We can also plot the cluster membership for
each of the distinct samples using the GEX_proportions_barplot
function.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">GEX_proportions_barplot</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">stacked.plot =</span> T, <span class="at">source.group =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">target.group =</span> <span class="st">&quot;seurat_clusters&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#This function is very flexible and can be used to plot proportions of cells from and of any groups. For this use the source.group and target.group parameters to specify metadata columns.</span></span></code></pre></div>
<p>Finally, we can also look at the B cell markers.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">FeaturePlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>,<span class="at">features =</span> <span class="fu">c</span>(<span class="st">&quot;CD19&quot;</span>,<span class="st">&quot;PTPRC&quot;</span>, <span class="st">&quot;EBF1&quot;</span>, <span class="st">&quot;H2-K1&quot;</span>))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#To easily scout through genes in the dataset use:</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#View(as.data.frame(rownames(vgm[[2]])))</span></span></code></pre></div>
<p>Platypus also allows us to assign cell type/state identity to
different clusters by using GEX_phenotype. This function takes the
Seurat object as input and uses canonical markers to easily match the
clustering to known cell types. The user also has the possibility to use
a custom list of markers and their associated cell types/states.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#using defaults</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">2</span>]] <span class="ot">&lt;-</span> <span class="fu">GEX_phenotype</span>(vgm[[<span class="dv">2</span>]], <span class="at">default =</span> T)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#custom criteria</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#vgm[[2]] &lt;- GEX_phenotype(vgm[[2]], default = F,cell.state.markers=c(&quot;CD8A+;CCL5+;CD44+;IL7R-;CD19-&quot;,&quot;CD8A+;CCL5-;CD44+;IL7R+;CD19-&quot;),cell.state.names=c(&quot;EffectorCD8&quot;,&quot;MemoryCD8&quot;))</span></span></code></pre></div>
<p>The resulting Seurat object now contains a “cell.state” column which
can be used for annotation in the DimPlot function of the Seurat
package.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;cell.state&quot;</span>)</span></code></pre></div>
</div>
<div id="differential-gene-expression-analysis" class="section level2">
<h2>5. Differential Gene Expression Analysis</h2>
<p>After scaling, normalizing, and clustering the cells from the GEX
libraries we can now investigate which genes are differentially
expressed between either clusters or samples. First, we can investigate
the genes that define each of the clusters by using the GEX output of
the VGM function. Depending on the size of the dataset and the number of
cells this function can be quite slow. The output of this function is a
list in which each element contains the differentially expressed genes
for a given cluster. For example, the first element of the list will
correspond to a dataframe describing the genes for cluster0 that we
previously observed on the UMAP. This list object will correspond to the
length of the number of clusters that were previously calculated, and
has the same format as the FindMarkers function from Seurat. The pct.1
will correspond to the percentage of cells expressing the gene in the
cluster of interest, and the pct.2 to the percentage of cells in all
other clusters.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>gene_expression_cluster <span class="ot">&lt;-</span> <span class="fu">GEX_cluster_genes</span>(vgm[[<span class="dv">2</span>]],<span class="at">min.pct =</span> <span class="fl">0.25</span>) </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(gene_expression_cluster) <span class="co"># length of 8, corresponding to 8 clusters</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(<span class="fu">unique</span>(vgm[[<span class="dv">2</span>]]<span class="sc">$</span>seurat_clusters)) <span class="co"># length of 8</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">sapply</span>(gene_expression_cluster,nrow)) <span class="co">#Nr of differentially expressed genes per cluster</span></span></code></pre></div>
<p>We can now look at some of the genes associated with cluster0 in the
previously displayed umap</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gene_expression_cluster[[<span class="dv">1</span>]])</span></code></pre></div>
<p>Raw tables are informative, but not visually appealing.
Differentially expressed genes may be plotted in different modes using
Platypus.</p>
<p>It is also possible to create a heatmap displaying differentially
expressed genes for each cluster. This can be customized to sub-sample
cells in case certain clusters are too large for visualization purposes.
Additionally, the user can determine the number of genes to display for
each cluster based on the n.genes.per.cluster argument. The function
GEX_cluster_genes_heatmap can be used to produce a ggplot object, based
on the DoHeatmap from Seurat.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>agedCNS_heatmap_clusters <span class="ot">&lt;-</span> <span class="fu">GEX_cluster_genes_heatmap</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">GEX_cluster_genes.output =</span> gene_expression_cluster,<span class="at">n.genes.per.cluster =</span> <span class="dv">3</span>,<span class="at">max.cell =</span> <span class="dv">30</span>,<span class="at">metric =</span> <span class="st">&quot;avg_logFC&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(agedCNS_heatmap_clusters)</span></code></pre></div>
<p>After plotting the ggplot object we can clearly see genes enriched in
various clusters - mainly indicated by the diagonal.</p>
<p>Further, volcano plots may be used to show and annotate a larger
number of differentially expressed genes</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>agedCNS_heatmap_volcano <span class="ot">&lt;-</span> <span class="fu">GEX_volcano</span>(<span class="at">DEGs.input =</span> gene_expression_cluster, <span class="at">input.type =</span> <span class="st">&quot;cluster.genes&quot;</span>, <span class="at">RP.MT.filter =</span> T, <span class="at">color.p.threshold =</span> <span class="fl">0.01</span>, <span class="at">n.label.up =</span> <span class="dv">10</span>, <span class="at">n.label.down =</span> <span class="dv">10</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(agedCNS_heatmap_volcano[[<span class="dv">1</span>]]) <span class="co">#genes specific to cluster 0</span></span></code></pre></div>
<p>Earlier we mentioned how we can match the unbiased clustering to
known cell types using canonical markers. Platypus also allows us to run
a GO or KEGG term analysis in order to obtain information on the most
significant GO/KEGG terms and their visualizations using the GEX_GOterm
function. (To do this, we first need to organize the top genes that
define each Seurat cluster and convert them into a single dataframe.
This is done using the GEX_topN_DE_genes_per_cluster function). This
function does require internet connection.</p>
<p>To return plots as PDF directly to the current working directory set
go.plot = T</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ontology_agedCNS <span class="ot">&lt;-</span> <span class="fu">GEX_GOterm</span>(<span class="at">GEX.cluster.genes.output =</span> gene_expression_cluster, <span class="at">topNgenes =</span> <span class="dv">10</span>, <span class="at">go.plots =</span> F)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(ontology_agedCNS[[<span class="dv">1</span>]][[<span class="dv">1</span>]]) <span class="co">#Cluster 0 </span></span></code></pre></div>
<p>We can additionally extract the top N genes per cluster directly
(with filtering) using the following function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>top_10_genes_per_cluster <span class="ot">&lt;-</span> <span class="fu">GEX_topN_DE_genes_per_cluster</span>(<span class="at">GEX_cluster_genes.output =</span> gene_expression_cluster, <span class="at">n.genes =</span> <span class="dv">10</span>, <span class="at">by_FC =</span> T)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(top_10_genes_per_cluster)</span></code></pre></div>
<p>We can also perform a Gene Set Enrichment Analysis (GSEA) using the
GEX_GSEA function. For this, the user needs to provide the path to a gmt
file containing the gene sets, which can be downloaded for example from
MSigDB. For instance we can perform GSEA for cluster0 and look at the
most significant pathways.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>gsea_EAE <span class="ot">&lt;-</span> <span class="fu">GEX_GSEA</span>(<span class="at">GEX.cluster.genes.output =</span> gene_expression_cluster[[<span class="dv">1</span>]], <span class="at">MT.Rb.filter =</span> T, <span class="at">path.to.pathways =</span> <span class="st">&quot;~/Downloads/c7.all.v7.4.symbols.gmt&quot;</span>)</span></code></pre></div>
<p>We can extract and test for differential expressed genes between the
two samples (or between other subgroups) by using the
GEX_DEgenes_persample function.</p>
<p>This function allows us to also create a heatmap displaying the top
most up- or downregulated genes for each cluster based on log fold
change (avg_logFC) or p value (adj_p_value). Additionally, the user can
determine the number of up- and downreulated genes to be displayed for
each sample. In this case, the output returns a list where the first
element contains the dataframe with the differntial expression
information and the second element contains the heatmap displaying the
most up-/downregulated genes.<br />
If more than two samples are to be examined please refer to
GEX_pairwise_degs two chunks below</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>DE_genes_samples <span class="ot">&lt;-</span> <span class="fu">GEX_DEgenes</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]],<span class="at">min.pct =</span> .<span class="dv">25</span>, <span class="at">grouping.column =</span> <span class="st">&quot;sample_id&quot;</span>,<span class="at">group1 =</span> <span class="st">&quot;s1&quot;</span>, <span class="at">group2 =</span> <span class="st">&quot;s2&quot;</span>,<span class="at">return.plot =</span> <span class="st">&quot;volcano&quot;</span>,<span class="at">up.genes =</span> <span class="dv">5</span>,<span class="at">down.genes =</span> <span class="dv">5</span>,<span class="at">logFC =</span> F)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">#This function is flexible and takes any column name as grouping.column to allow easy exploration of differences between custom groups</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(DE_genes_samples[[<span class="dv">1</span>]]) </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>DE_genes_samples[[<span class="dv">2</span>]] </span></code></pre></div>
<p>The same function can also return DEGs between seurat clusters or any
2 groups of cells Here DEGs between cluster 1 and 3 are calculated</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>DE_genes_cl1_vs_3 <span class="ot">&lt;-</span> <span class="fu">GEX_DEgenes</span>(<span class="at">GEX=</span> vgm[[<span class="dv">2</span>]],<span class="at">min.pct =</span> .<span class="dv">25</span>, <span class="at">grouping.column =</span> <span class="st">&quot;seurat_clusters&quot;</span>,<span class="at">group1 =</span> <span class="st">&quot;1&quot;</span>, <span class="at">group2 =</span> <span class="st">&quot;3&quot;</span>,<span class="at">return.plot =</span> <span class="st">&quot;heatmap&quot;</span>,<span class="at">up.genes =</span> <span class="dv">10</span>,<span class="at">down.genes =</span> <span class="dv">10</span>,<span class="at">logFC =</span> F)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#head(DE_genes_cl1_vs_3[[1]]) </span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>DE_genes_cl1_vs_3[[<span class="dv">2</span>]] </span></code></pre></div>
<p>To gain a complete overview of DEGs between groups or clusters the
GEX_pairwise_degs function is used This function calculates DEGs for
every possible pairwise comparison between groups of the selected
column. It is thereby recommended to use this function with a maximum
number of 10 groups/clusters/samples This function automatically saves
plots where top label.n.top.genes genes are labeled by their p value.
Additionally, genes of special interest that should be labeled
irregardless of their p value can be supplied to genes.to.label</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">#DE_clusters_all &lt;- GEX_pairwise_DEGs(GEX = vgm[[2]], group.by = &quot;seurat_clusters&quot;, min.pct = 0.25, RP.MT.filter = T, label.n.top.genes = 10, genes.to.label = c(&quot;CD74&quot;, &quot;EBF1&quot;), save.plot = F)</span></span></code></pre></div>
<p>Now that cluster defining genes have been examined, a helper plotting
function allows to visualize selected genes.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>dottile <span class="ot">&lt;-</span> <span class="fu">GEX_dottile_plot</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">genes =</span> <span class="fu">c</span>(<span class="st">&quot;CD19&quot;</span>, <span class="st">&quot;CD74&quot;</span>,<span class="st">&quot;SDC1&quot;</span>, <span class="st">&quot;EBF1&quot;</span>,<span class="st">&quot;PTPRC&quot;</span>,<span class="st">&quot;CD93&quot;</span>,<span class="st">&quot;CD38&quot;</span>,<span class="st">&quot;CD24A&quot;</span>,<span class="st">&quot;CD34&quot;</span>,<span class="st">&quot;CD1D1&quot;</span>,<span class="st">&quot;CR2&quot;</span>,<span class="st">&quot;MS4A1&quot;</span>,<span class="st">&quot;CXCR5&quot;</span>,<span class="st">&quot;SELL&quot;</span>,<span class="st">&quot;CD40&quot;</span>,<span class="st">&quot;CD83&quot;</span>,<span class="st">&quot;H2-AB1&quot;</span>,<span class="st">&quot;H2-EB1&quot;</span>,<span class="st">&quot;CD27&quot;</span>,<span class="st">&quot;POU2AF1&quot;</span>,<span class="st">&quot;NT5E&quot;</span>,<span class="st">&quot;FAS&quot;</span>,<span class="st">&quot;PDCD1LG2&quot;</span>,<span class="st">&quot;PRDM1&quot;</span>,<span class="st">&quot;ITGAM&quot;</span>,<span class="st">&quot;IL10&quot;</span>,<span class="st">&quot;IL12A&quot;</span>,<span class="st">&quot;HAVCR2&quot;</span>), <span class="at">group.by =</span> <span class="st">&quot;seurat_clusters&quot;</span>, <span class="at">threshold.to.plot =</span> <span class="dv">5</span>) </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">#threshold.to.plot specifies how many % of cells have to express a gene to show a dot.</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>dottile <span class="sc">+</span> ggplot2<span class="sc">::</span><span class="fu">theme</span>(<span class="at">plot.title =</span> ggplot2<span class="sc">::</span><span class="fu">element_blank</span>(), <span class="at">plot.subtitle =</span> ggplot2<span class="sc">::</span><span class="fu">element_blank</span>(), <span class="at">legend.position =</span> <span class="st">&quot;bottom&quot;</span>) </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">#For visualisation purposes in the RMD format</span></span></code></pre></div>
<p>To examine patterns of co-expression two functions allow to generate
both overview and single-cell resolution plots.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">#overview</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>coexpression_dotmap <span class="ot">&lt;-</span> <span class="fu">GEX_coexpression_coefficient</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">genes =</span> <span class="fu">c</span>(<span class="st">&quot;CD19&quot;</span>, <span class="st">&quot;CD74&quot;</span>,<span class="st">&quot;SDC1&quot;</span>, <span class="st">&quot;EBF1&quot;</span>,<span class="st">&quot;PTPRC&quot;</span>,<span class="st">&quot;CD93&quot;</span>,<span class="st">&quot;CD38&quot;</span>,<span class="st">&quot;CD24A&quot;</span>,<span class="st">&quot;CD34&quot;</span>), <span class="at">plot.dotmap =</span> T)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>coexpression_dotmap <span class="sc">+</span> ggplot2<span class="sc">::</span><span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">#detail of two selected genes</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="fu">GEX_scatter_coexpression</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">gene.1 =</span> <span class="st">&quot;CD19&quot;</span>, <span class="at">gene.2 =</span> <span class="st">&quot;EBF1&quot;</span>, <span class="at">color.theme =</span> <span class="st">&quot;darkred&quot;</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">#to save use: </span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">#ggsave(last_plot(), filename = &quot;Coexpression_scatter.png&quot;)</span></span></code></pre></div>
</div>
<div id="vdj-repertoire-anaylsis" class="section level2">
<h2>6. VDJ Repertoire anaylsis</h2>
<div id="checking-vgm-output" class="section level3">
<h3>6.1 Checking vgm output</h3>
<p>Now we can analyze the VDJ repertoire data before integrating VDJ and
GEX information. This may be useful if only VDJ libraries have been
sequenced without the accompanying gene expression data. We first start
by examining the structure of vgm[[1]]</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">colnames</span>(vgm[[<span class="dv">1</span>]]))</span></code></pre></div>
<p>If GEX data has been integrated, this dataframe also contains
dimensional reduction coordinates and cluster id. If trim.and.align was
set to TRUE, the columns VDJ_sequence_nt_trimmed to VJ_trimmed_ref
contain aligned and reference sequences. The clonotype_frequency column
takes input from the clonotyping output of cellranger, which is saved
int the clonotype_id_10x column.</p>
<p>This object contains both cells with less than 2 V(D)J chains as well
as with more than 2 To show how this is done the VDJ_cgene column is
taken as an example</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">unique</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>VDJ_cgene))</span></code></pre></div>
<p>Apart from classical isotypes, we can see an empty (““) element. This
is for cells, for which only a VJ chain is available. Secondly we can
see 3 examples of cells containing more than one VDJ chains. These are
delimited by”;“. Importantly, this format is maintained throughout all
columns.</p>
<p>Both cells with less and more than 2 chains can be cumbersome for
analysis. Platypus V3 functions generally support such cells. To check
their quantity and, if needed, exclude these, the following line can be
used</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot; Cell count by number of VDJ chains&quot;</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">table</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>Nr_of_VDJ_chains)) </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st"> Cell count by number of VJ chains&quot;</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">table</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>Nr_of_VJ_chains)) </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Subset the VGM matrix to only include cells with 1 VDJ and 1VJ chain</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co">#vgm[[1]] &lt;- subset(vgm[[1]], Nr_of_VJ_chains == 1 &amp; Nr_of_VJ_chains == 1)</span></span></code></pre></div>
</div>
<div id="changing-the-clonotype-strategy" class="section level3">
<h3>6.2 Changing the clonotype strategy</h3>
<p>Often paired nucleotide CDRH3 and CDRL3 clonotyping may not be the
best strategy given somatic hypermutation may occur in the CDR3 region.
Therefore, there could be highly similar clones that likely bind the
same antigen that are officially part of different clonal families. To
address this, we have added a function that allows for various heuristic
clonotyping strategies. This involves clonotyping by identical amino
acid CDRH3 + CDRL3 seuqence, identical germline usage, or seqeunce
homology requirements. This function works both for V3 of platypus.</p>
<p>global.clonotype If set to TRUE, clonotypes will be generated across
all samples of the vgm. This may be useful if more than one sample has
been taken from the same animal (e.g. spleen and bone marrow)</p>
<p>A note for cells with aberrant numbers of VDJ and VJ chains: the
functions implements a hierarchical clonotyping strategy for such cells.
In brief, clonotypes are determined based on all cells with exactly 1VDJ
and 1VJ chain. Other cells are then “joined in” in post. Two examples
for illustration of the hierarchical mode “single.chains”: 1. A cell
with 0VDJ and 1VJ chain is joined to an existing clonotype containing
the same or a homologous VJ chain, depending of the clonotyping
strategy. 2. A cell with 1VDJ and 2VJ chain will be matched to a
clonotype that contains either of the two possible combinations of the
chains of that aberrant cell. In case that no existing clonotype matches
the abberant cell in question, a new clonotype will be assigned In case
of multiple matching clonotypes, abberant cells will be assigned to the
most frequent of them. Cells with 2VDJ and 2VJ chains are excluded as
these most likely correspond to doublets. Further the function
implements the hierarchical mode “double.and.single.chains” Here the
function will proceed as if set to “single.chains” but include two more
steps 3. Check the frequency of each cell 1 VDJ 2 VJ chain exact clone
(by exact nucleotide CDR3 matching). Only if this count exceeds the
triple.chain.count.threshold, the clone is used as a “hub clone”. This
protects from merging clonotypes on the basis of rare doublets. 4. Merge
existing clonotypes into the 1 VDJ 2 VJ clonotypes as they match with
the assumption that e.g. a cell with 1 VDJ 1 VJ is part of that same
clonotype, but missing a VJ chain due to stochastical sampling</p>
<p>In the example that follows, we use VDJ_clonotype to group cells into
clones based on identical CDRH3 + CDRL3 amino acid sequence. We will
compare this to the case in which we group B cells by using the same
germline genes (both heavy chain and light chain).</p>
<p>The function adds new columns containing clonotype ids, features and
frequencies, named based on the clonotyping strategy. This allows
multiple clonotyping strategy outputs to be stored in the same VGM
object</p>
<p>The columns clonotype_frequency and clonotype_id are considered the
“active” slot, as functions downstream pull from them. These two columns
are updated every time the VDJ_clonotype function is run</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">VDJ_clonotype</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">clone.strategy =</span> <span class="st">&quot;cdr3.aa&quot;</span>, <span class="at">global.clonotype =</span> F, <span class="at">VDJ.VJ.1chain =</span> F, <span class="at">hierarchical =</span> <span class="st">&quot;single.chains&quot;</span>) <span class="co">#Not filtering cells with counts other than 1VDJ 1VJ chain and integrating these cells hierarchically into clonotypes</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot; Nr and distribution of clonotypes using exact CDR3.aa matching </span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">length</span>(<span class="fu">unique</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>clonotype_id_cdr3.aa)))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">table</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>clonotype_frequency_cdr3.aa)) <span class="co">#Check distribution of clonotypes with identical CDR3 aa sequences</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">VDJ_clonotype</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">clone.strategy =</span> <span class="st">&quot;hvj.lvj&quot;</span>, <span class="at">global.clonotype =</span> F, <span class="at">output.format =</span> <span class="st">&quot;vgm&quot;</span>, <span class="at">VDJ.VJ.1chain =</span> F, <span class="at">hierarchical =</span> <span class="st">&quot;single.chains&quot;</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st"> Nr and distribution of clonotypes using germline gene matching </span><span class="sc">\n</span><span class="st"> &quot;</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">length</span>(<span class="fu">unique</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>clonotype_id_hvj.lvj)))</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">table</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>clonotype_frequency_hvj.lvj)) <span class="co">#Check distribution of clonotypes with identical germline genes</span></span></code></pre></div>
</div>
<div id="extracting-full-length-sequences-from-the-vdjregion" class="section level3">
<h3>6.3 Extracting full-length sequences from the VDJRegion</h3>
<p>At the start of this vignette the VGM function was run with
trim.and.align = F. Here we run the function again, but this time with
trim.and.align = T. This does take significantly longer</p>
<p>To accelerate runtime, parallel computing options are available. If
running a Windows machine parallel.processing should be set to
“parlapply” This does require the package Parallel and its dependencies.
The additional parameter numcores allows to set the numbers of cores to
use. This is important when running the function on a cluster. If on a
MAC or Linux machine, set parallel.processing to “mclapply”</p>
<p>Reference sequences are optained from the cellranger output and
thereby the 10x Genomics reference. Further trimming is made based on
annotations by cellranger (feature$region_type). Alignment is done via
Biostrings::pairwiseAlignment and the alignment with maximum score is
returned. If alignments are not complete, the vgm parameters
gap.opening.cost and gap.extension.cost can be modified</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>vgm <span class="ot">&lt;-</span> <span class="fu">VDJ_GEX_matrix</span>(<span class="at">VDJ.out.directory.list =</span> VDJ.out.directory.list,</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">GEX.out.directory.list =</span> GEX.out.directory.list,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">GEX.integrate =</span> T,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">VDJ.combine =</span> T,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>                               <span class="at">integrate.GEX.to.VDJ =</span> T,</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>                               <span class="at">integrate.VDJ.to.GEX =</span> T, </span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>                               <span class="at">exclude.GEX.not.in.VDJ =</span> F,</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>                               <span class="at">filter.overlapping.barcodes.GEX =</span> T,</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>                               <span class="at">filter.overlapping.barcodes.VDJ =</span> T,</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>                               <span class="at">exclude.on.cell.state.markers =</span> <span class="fu">c</span>(<span class="st">&quot;CD3E&quot;</span>),</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>                               <span class="at">get.VDJ.stats =</span> T,</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>                               <span class="at">parallel.processing =</span> <span class="st">&quot;none&quot;</span>, </span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>                               <span class="at">trim.and.align =</span> T, <span class="co">#Set this to TRUE for full length sequence recovery</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>                               <span class="at">group.id =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>                               <span class="at">gap.opening.cost =</span> <span class="dv">10</span>,</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>                               <span class="at">gap.extension.cost =</span> <span class="dv">4</span>) <span class="co">#Tweak to optimize alignments if neccessary</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="co">#saving this for later</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="co">#saveRDS(vgm, &quot;VDJ_GEX_matrix_agedCNS.rds&quot;)</span></span></code></pre></div>
<p>No trimmed and reference sequence columns should be filled.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(vgm[[<span class="dv">1</span>]][<span class="dv">1</span>,])</span></code></pre></div>
<p>A different way to get germline reference sequences is by using
MIXCR. MIXCR can be called directly from R on both Windows and MAC
machines. Given that output files have to be read in, it is important to
set the working directory correctly and (Essential for Windows users)
have a version of MIXCR available in that working directory.</p>
<p>Moreover to quantify the number of somatic variants or to extract
full-length sequences for expression, it is often useful to have the
nucleotide sequence from framework region 1 (FR1) to framework region 4
(FR4). Using the call_MIXCR function, the full-length VDJRegion
sequences can be added to the clonal information and easily extracted
thereafter. This function works on UNIX/Mac and furthermore requires
that mixcr is already downloaded locally (with license agreement).</p>
<p>FOR MAC/UNIX users</p>
<p>One needs to supply the directory to the executable in the call_MIXCR
function as below. Either “mmu” or “hsa” for mouse and human,
respectively. Again, the format is similar to the input, in that the
outer list corresponds to the individual repertoire and the inner list
is a dataframe with various information, including the full-length VDJ
sequences (e.g., VDJ.AA.LC and VDJ.AA.HC for the light and heavy chain
amino acid sequence). One will notice that the germline sequence is
still very long (e.g., in the example below the “full_HC_germline”
length is over 600 nucleotides). This will be filled in using the
separate function VDJ_extract_germline.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="do">### </span><span class="al">WARNING</span><span class="do">: You will need to download MiXCR and change the mixcr.directory to the location of MiXCR</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ_mixcr_out &lt;- VDJ_call_MIXCR(VDJ.matrix = vgm[[1]], mixcr.directory = &quot;~/Downloads/mixcr.jar&quot;,species = &quot;mmu&quot;, platypus.version = &quot;v3&quot;, operating.system = &quot;Darwin&quot;, simplify = T)</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">#set simplify to T to append only a selected columns of the MIXCR output to the vgm matrix</span></span></code></pre></div>
<p>FOR Windows users The mixcr.jar executable needs to be in the current
working directory!</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">#check working directory</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">#getwd()</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="do">### </span><span class="al">WARNING</span><span class="do">: You will need to download MiXCR and have it in your current working directory</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>VDJ_mixcr_out <span class="ot">&lt;-</span> <span class="fu">VDJ_call_MIXCR</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">mixcr.directory =</span> <span class="st">&quot;Is set automatically to current working directory&quot;</span>,<span class="at">species =</span> <span class="st">&quot;mmu&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">operating.system =</span> <span class="st">&quot;Windows&quot;</span>, <span class="at">simplify =</span> T)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co">#set simplify to T to append only a selected columns of the MIXCR output to the vgm matrix</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co">#set to False to save as separate object with the complete MIXCR output as in this case</span></span></code></pre></div>
</div>
<div id="plotting-shms" class="section level3">
<h3>6.5 Plotting SHMs</h3>
<p>Directly from the MIXCR output we can plot the frequency of somatic
hypermutations and run basic tests of significance between groups</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">VDJ_plot_SHM</span>(<span class="at">VDJ =</span> VDJ_mixcr_out, <span class="at">group.by =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">quantile.label =</span> <span class="fl">0.95</span>)</span></code></pre></div>
</div>
<div id="visualizing-clonal-frequencies-v3-only" class="section level3">
<h3>7.1 Visualizing clonal frequencies (V3 only)</h3>
<p>For a basic view of clonal expansion the VDJ_clonal_donut produces
circular plots per sample. Label position and size should only be
adjusted after deciding on a plot export format. This function uses the
clonotype_id column as input. If VDJ_clonotyping function was used, its
result are stored in that column. If not, the default 10x clonotyping is
stored there. To retrieve default 10x clonotyping, use the column
clonotyping_id_10x</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>donuts <span class="ot">&lt;-</span> <span class="fu">VDJ_clonal_donut</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">expanded.colors =</span> <span class="fu">c</span>(<span class="st">&quot;grey50&quot;</span>, <span class="st">&quot;grey65&quot;</span>, <span class="st">&quot;grey80&quot;</span>), <span class="at">non.expanded.color =</span> <span class="st">&quot;black&quot;</span>, <span class="at">counts.to.use =</span> <span class="st">&quot;freq_column&quot;</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Counts to use = &quot;freq_column&quot; uses the counts in the clonotype_frequency column. Counts to use = &quot;vgm&quot; simply counts the rows of a given clonotype in the VGM table (these counts may differ if cells have been filtered out due to overlapping barcodes or if another clonotyping strategy was used)</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>donuts[[<span class="dv">1</span>]]</span></code></pre></div>
<p>The black section shows cells in unexpanded clones. The rest shows
expanded clones by their frequency. The middle label shows the total
number of clones (cells)</p>
</div>
<div id="calculating-common-repertoire-diversity-metrics" class="section level3">
<h3>7.2 Calculating common repertoire diversity metrics</h3>
<p>This requires the Vegan package. We can calculate the diversity for
any column(s) in the vgm. If more than one column is provided, the
content will be pasted together before calculating diversity metrics</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Shannon Evenness for the VDJ chain CDR3</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>diversity_plot <span class="ot">&lt;-</span> <span class="fu">VDJ_diversity</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">feature.columns =</span> <span class="fu">c</span>(<span class="st">&quot;VDJ_cdr3s_aa&quot;</span>),<span class="at">grouping.column =</span> <span class="st">&quot;sample_id&quot;</span>,<span class="at">metric =</span> <span class="fu">c</span>(<span class="st">&quot;shannonevenness&quot;</span>), <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">subsample.to.same.n =</span> T)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>diversity_plot</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Gini-Simpson index for pasted VDJ and VJ chain CDR3s</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>diversity_plot <span class="ot">&lt;-</span> <span class="fu">VDJ_diversity</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">feature.columns =</span> <span class="fu">c</span>(<span class="st">&quot;VDJ_cdr3s_aa&quot;</span>, <span class="st">&quot;VJ_cdr3s_aa&quot;</span>),<span class="at">grouping.column =</span> <span class="st">&quot;sample_id&quot;</span>,<span class="at">metric =</span> <span class="fu">c</span>(<span class="st">&quot;ginisimpson&quot;</span>), <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">subsample.to.same.n =</span> T)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>diversity_plot</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co">#exact values can be retrived as </span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(diversity_plot<span class="sc">$</span>data))</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Jaccard index between repertoires of the two samples</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>diversity_plot <span class="ot">&lt;-</span> <span class="fu">VDJ_diversity</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">feature.columns =</span> <span class="fu">c</span>(<span class="st">&quot;VDJ_cgene&quot;</span>),<span class="at">grouping.column =</span> <span class="st">&quot;sample_id&quot;</span>,<span class="at">metric =</span> <span class="fu">c</span>(<span class="st">&quot;jaccard&quot;</span>), <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">subsample.to.same.n =</span> T)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>diversity_plot </span></code></pre></div>
</div>
<div id="examining-isotypes" class="section level3">
<h3>7.3 Examining isotypes</h3>
<p>Additional VDJ functions include plotting the clonal expansion for
each clone. This can be performed by the VDJ_clonal_expansion function
and setting the number of clones to show.</p>
<p>The function has two operating modes: Set color.by to “isotype” to
exctract and color bars by isotype. Set subtypes to TRUE to view IgG
subtypes. Set color.by to any other column in vgm[[1]] to examine the
distribution of other parameters (This will be used during VDJ - GEX
integration)</p>
<p>The following code extracts and plots the isotype distribution of the
top 30 clones. We can see a clear IgA isotype majority of the top four
clones in the first patient when using the default clonotyping strategy.
We can additionally use the new clonotyping strategies to compare how
changing the clonal defintion impacts the clonal expansion profiles. We
simply supply the output from VDJ_clonotype</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>clonal_out <span class="ot">&lt;-</span> <span class="fu">VDJ_clonal_expansion</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">celltype =</span> <span class="st">&quot;Bcells&quot;</span>,<span class="at">clones =</span> <span class="st">&quot;30&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">color.by =</span> <span class="st">&quot;isotype&quot;</span>, <span class="at">isotypes.to.plot =</span> <span class="st">&quot;all&quot;</span>, <span class="at">treat.incomplete.clones =</span> <span class="st">&quot;exclude&quot;</span>, <span class="at">treat.incomplete.cells =</span> <span class="st">&quot;proportional&quot;</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#group by specifies how many separate plots should be generated. If vgm contains global clonotype information this can be set to &quot;none&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(clonal_out[[<span class="dv">1</span>]])</span></code></pre></div>
</div>
<div id="sequence-similarity-networks" class="section level3">
<h3>7.4 Sequence similarity networks</h3>
<p>Other functions are specifically tailored to repertoire analysis -
such as VDJ_network, which creates a sequence similarity network between
repertoires or within a repertoire by connecting those clones with
sequence similarity. This function relies upon igraph to visually
display and construct the graph - which means that networks with high
number of sequences will not display easily. In the following example we
are using a small dataset. In case of a bigger dataset one may subsample
by using the sample.n function on vgm[[1]]. Setting the per.mouse
argument to false indicates that one network for multiple repertoires
should be produced.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">#subsampled_VGM &lt;- dplyr::sample_n(vgm[[1]], 60)</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>agedCNS_igraph <span class="ot">&lt;-</span> <span class="fu">VDJ_network</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">per.sample =</span> T,<span class="at">distance.cutoff =</span> <span class="dv">8</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">plot.igraph</span>(agedCNS_igraph[[<span class="dv">1</span>]][[i]],<span class="at">vertex.label=</span><span class="cn">NA</span>,<span class="at">vertex.size=</span><span class="dv">7</span>)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="co">#For a plot including clonotype frequencies</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>agedCNS_igraph <span class="ot">&lt;-</span> <span class="fu">VDJ_network</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">per.sample =</span> F,<span class="at">distance.cutoff =</span> <span class="dv">8</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">plot.igraph</span>(agedCNS_igraph[[<span class="dv">4</span>]],<span class="at">vertex.label=</span><span class="cn">NA</span>,<span class="at">vertex.size=</span><span class="dv">3</span><span class="sc">+</span>(.<span class="dv">03</span><span class="sc">*</span><span class="fu">as.numeric</span>(agedCNS_igraph[[<span class="dv">2</span>]]<span class="sc">$</span>clonotype_frequency)),<span class="at">vertex.color=</span> <span class="fu">as.factor</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>sample_id))</span></code></pre></div>
<p>For more details see the documentation of the VDJ_network function,
but essentially information such as clonal frequency and which sample
(here still indicated by the “sample_id” column) are stored in the
second element of the output list. Here we can see only a few clones
that are showing connections (produced by edges between those with a
distance of 8 amino acids or less between heavy and light chain paired
CDR3 sequence homology)</p>
</div>
<div id="germline-gene-usage-heatmaps" class="section level3">
<h3>7.5 Germline gene usage heatmaps</h3>
<p>It is also possible to produce heatmaps of the germline gene usage in
the context of heavy chain V gene and light chain V gene. The output of
the VDJ_Vgene_usage function is a matrix for each repertoire
corresponding to the order specified by VDJ_analyze. The outer list
corresponds to the sample and the inner list corresponds to a matrix,
where the rows correspond to the heavy chain V genes and the columns
correspond to the light chains of the V genes. Therefore the
output[[1]][i,j] corresponds to the number of clones using the
combination of IGH-Vgene[i] and IGK/L-Vgene[j].</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">#First calculate adjacency matrix for V gene usage</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>agedCNS_Vgene_usage <span class="ot">&lt;-</span> <span class="fu">VDJ_Vgene_usage</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">#library(pheatmap)</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>pheatmap<span class="sc">::</span><span class="fu">pheatmap</span>(agedCNS_Vgene_usage[[<span class="dv">1</span>]],<span class="at">show_rownames =</span> F,<span class="at">show_colnames =</span> F)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">class</span>(agedCNS_Vgene_usage[[<span class="dv">1</span>]]))</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(<span class="fu">rownames</span>(agedCNS_Vgene_usage[[<span class="dv">1</span>]])))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(<span class="fu">colnames</span>(agedCNS_Vgene_usage[[<span class="dv">1</span>]])))</span></code></pre></div>
<p>This can then be easily plotted as a heatmap to observe patterns
between repertoires or can be used to calculate V gene correlation using
the “pheatmap” package.</p>
<p>Platypus also allows a separate analysis of V gene usage for HC and
LC. The VDJ_Vgene_usage_barplot allows the user to plot most frequently
used IgH or IgK/L V genes. By default, this function only provides
visualizations for the HC V genes, but can also provide for the LC if
LC. Vgene is set to TRUE. The User can also select the number of most
used genes to be depicted.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>agedCNS_Vgene_usage_barplot <span class="ot">&lt;-</span> <span class="fu">VDJ_Vgene_usage_barplot</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">HC.gene.number =</span> <span class="dv">10</span>, <span class="at">LC.Vgene =</span> T, <span class="at">LC.gene.number =</span> <span class="dv">10</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>agedCNS_Vgene_usage_barplot[[<span class="dv">1</span>]]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ chains</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>agedCNS_Vgene_usage_stackedbarplot <span class="ot">&lt;-</span> <span class="fu">VDJ_Vgene_usage_stacked_barplot</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">LC.Vgene =</span> F,<span class="at">HC.gene.number =</span> <span class="dv">10</span>, <span class="at">Fraction.HC =</span> <span class="dv">1</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>agedCNS_Vgene_usage_stackedbarplot</span></code></pre></div>
<p>Furthermore, we can also produce a circular visualization of how V
and J genes are combined throughout the repertoire. In the example that
follows we use VDJ_VJ_usage_circos to look at the V gene with the
corresponding J gene for each expanded clonotype.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ and VJ V and J gene pairing</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>vj_circos_bcells <span class="ot">&lt;-</span> <span class="fu">VDJ_VJ_usage_circos</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">c.threshold =</span> <span class="dv">1</span>,<span class="at">label.threshold=</span><span class="dv">2</span>,<span class="at">cell.level =</span> T, <span class="at">A.or.B =</span> <span class="st">&quot;both&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ and VJ pairing </span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>HL_circos_bcells <span class="ot">&lt;-</span> <span class="fu">VDJ_alpha_beta_Vgene_circos</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">c.threshold =</span> <span class="dv">1</span>,<span class="at">label.threshold=</span><span class="dv">2</span>,<span class="at">cell.level =</span> T, <span class="at">V.or.J=</span> <span class="st">&quot;both&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span></code></pre></div>
</div>
<div id="assessing-cdr3-sequence-similarity" class="section level3">
<h3>7.6 Assessing CDR3 sequence similarity</h3>
<p>Finally, one can also look at any specific HC and LC CDR3 amino acid
patterns arising across the different clones. Using the
VDJ_logoplot_vector function the user can plot a logoplot of the CDR3
region od a certain length, specyfied by the length_cdr3 argument. For
instance, the logoplot below corresponds to all those CDR3 aminoacid
sequences of length 25</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>pasted_CDR3s <span class="ot">&lt;-</span> <span class="fu">paste0</span>(vgm[[<span class="dv">1</span>]]<span class="sc">$</span>VDJ_cdr3s_aa, vgm[[<span class="dv">1</span>]]<span class="sc">$</span>VJ_cdr3s_aa)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>agedCNS_CDR3_logoplot <span class="ot">&lt;-</span> <span class="fu">VDJ_logoplot_vector</span>(<span class="at">cdr3.vector =</span> pasted_CDR3s, <span class="at">seq_type =</span> <span class="st">&quot;aa&quot;</span>, <span class="at">length_cdr3 =</span> <span class="st">&quot;auto&quot;</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(agedCNS_CDR3_logoplot)</span></code></pre></div>
</div>
<div id="assessing-nr-of-variants-per-clone" class="section level3">
<h3>7.7. Assessing Nr of variants per clone</h3>
<p>Depending on the clonotype strategy, within a clone several different
variants of CDR3s or full length sequences may be contained. To count
variants, the function VDJ_variants_per_clone is used. It returns a
table per sample_id with stats about variants</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>variants_agedCNS <span class="ot">&lt;-</span> <span class="fu">VDJ_variants_per_clone</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]], <span class="at">variants.of =</span> <span class="fu">c</span>(<span class="st">&quot;VDJ_cdr3s_aa&quot;</span>, <span class="st">&quot;VJ_cdr3s_aa&quot;</span>), <span class="at">clonotypes.col =</span> <span class="st">&quot;clonotype_id_10x&quot;</span>, <span class="at">split.by =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">stringDist.method =</span> <span class="st">&quot;levenshtein&quot;</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(variants_agedCNS[[<span class="dv">1</span>]])</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co">#set split.by to &quot;none&quot; if clonotyping was conducted across all samples</span></span></code></pre></div>
</div>
<div id="searching-for-overlap-between-repertoires" class="section level3">
<h3>7.8. Searching for overlap between repertoires</h3>
<p>Public clones or sequences are sequences that are shared between
individuals. The VDJ_overlap_heatmap function can quantify this overlap
and return a list of overlapping items</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">#overlap of VDJ V genes</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>VDJv_overlap <span class="ot">&lt;-</span> <span class="fu">VDJ_overlap_heatmap</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">feature.columns =</span> <span class="fu">c</span>(<span class="st">&quot;VDJ_vgene&quot;</span>) ,<span class="at">grouping.column =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">axis.label.size =</span> <span class="dv">20</span>, <span class="at">pvalues.label.size =</span> <span class="dv">12</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">add.barcode.table =</span> T, <span class="at">plot.type =</span> <span class="st">&quot;ggplot&quot;</span>) </span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>VDJv_overlap[[<span class="dv">2</span>]] <span class="co">#summary of overlap</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>VDJv_overlap[[<span class="dv">2</span>]] <span class="co">#Table of overlapping items</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co">#overlap of clones</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>VDJv_overlap <span class="ot">&lt;-</span> <span class="fu">VDJ_overlap_heatmap</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">feature.columns =</span> <span class="fu">c</span>(<span class="st">&quot;VDJ_cdr3s_aa&quot;</span>,<span class="st">&quot;VJ_cdr3s_aa&quot;</span>) ,<span class="at">grouping.column =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">axis.label.size =</span> <span class="dv">20</span>, <span class="at">pvalues.label.size =</span> <span class="dv">12</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">add.barcode.table =</span> T, <span class="at">plot.type =</span> <span class="st">&quot;ggplot&quot;</span>) </span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Pheatmap plots will function only with length(unique(grouping.column)) &gt; 3</span></span></code></pre></div>
<p>Given the small size of the two repertoires, it is unsurprising that
no clones are shared</p>
</div>
</div>
<div id="integrating-repertoire-and-gene-expression" class="section level2">
<h2>8. Integrating repertoire and gene expression</h2>
<p>The strength of the current 5’ sequencing protocols are that the gene
expression (GEX) and repertoire (VDJ) libraries are extracted from the
same sample, which can then be linked back to demonstrate that a given T
cell has a certain gene expression pattern and also a certain T cell
receptor sequence. The following functions are meant to integrate these
two pieces of information.</p>
<div id="integrating-transcriptional-clusters-to-the-vdj-objects" class="section level3">
<h3>8.1. Integrating transcriptional clusters to the VDJ objects</h3>
<p>One thing we may ask is how similar the B or T cells in a given
clonal family are on the transcriptional level. The basic work of
matching barcodes from V(D)J sequencing to those from GEX sequencing was
already done in the VGM function. This part is therefore dedicated to
functions that help explore and exploite this data</p>
<p>First we get basic stats on the overlap between GEX and VDJ</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Nr of cells for which VDJ info is available</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(vgm[[<span class="dv">1</span>]])</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co">#Nr of cells for which GEX info is available</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="fu">ncol</span>(vgm[[<span class="dv">2</span>]])</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">#VDJ sequences for which GEX is available</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(vgm[[<span class="dv">2</span>]]<span class="sc">$</span>VDJ_available)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="co">#We can also plot this </span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>Seurat<span class="sc">::</span><span class="fu">DimPlot</span>(vgm[[<span class="dv">2</span>]],<span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;VDJ_available&quot;</span>, <span class="at">shuffle =</span> T)</span></code></pre></div>
</div>
<div id="relating-clonal-expansion-to-transcriptional-cluster-membership" class="section level3">
<h3>8.2. Relating clonal expansion to transcriptional cluster
membership</h3>
<p>The VDJ_clonal_expansion function has been used above to plot isotype
information. Here its exdented functionality is used to color clones by
their transcriptional cluster</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>clonal_out <span class="ot">&lt;-</span> <span class="fu">VDJ_clonal_expansion</span>(<span class="at">VDJ =</span> vgm[[<span class="dv">1</span>]],<span class="at">celltype =</span> <span class="st">&quot;Bcells&quot;</span>,<span class="at">clones =</span> <span class="st">&quot;30&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>, <span class="at">group.by =</span> <span class="st">&quot;sample_id&quot;</span>, <span class="at">color.by =</span> <span class="st">&quot;seurat_clusters&quot;</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co">#group by specifies how many separate plots should be generated. If vgm contains global clonotype information this can be set to &quot;none&quot;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(clonal_out[[<span class="dv">1</span>]][[<span class="dv">2</span>]])</span></code></pre></div>
<p>Similar plots can be generated using the GEX_phenotype_per_clone
function</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>clonal_out <span class="ot">&lt;-</span> <span class="fu">GEX_phenotype_per_clone</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">GEX.clonotypes =</span> <span class="st">&quot;topclones&quot;</span>, <span class="at">GEX.group.by =</span> <span class="st">&quot;seurat_clusters&quot;</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">#If vgm contains global clonotype information this can be set global.clonotypes to TRUE</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>clonal_out[[<span class="dv">1</span>]]</span></code></pre></div>
</div>
<div id="visualizing-clones-on-the-2-dimensional-landscape" class="section level3">
<h3>8.3. Visualizing clones on the 2 dimensional landscape</h3>
<p>To better visualize this, the cells of any clone can also be
highlighted on a dimensional reduction</p>
<p>Because the legend of these plots can get quite large, we can split
the plot and the legend and draw them separately. For this the gridExtra
and cowplot package is required</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">#here we overlay the top 5 clones</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>plot_out <span class="ot">&lt;-</span> <span class="fu">VDJ_GEX_overlay_clones</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">n.clones =</span> <span class="dv">5</span>, <span class="at">by.sample =</span> F, <span class="at">ncol.facet =</span> <span class="dv">1</span>, <span class="at">split.plot.and.legend =</span> F, <span class="at">pt.size =</span> <span class="fl">0.5</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>plot_out[[<span class="dv">1</span>]] <span class="co"># the plot</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">#We can also plot any clone of interest by adding a column were TRUE values select which clones are to be plotted</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>interesting_clones <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;clonotype7&quot;</span>, <span class="st">&quot;clonotype42&quot;</span>)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">2</span>]]<span class="sc">@</span>meta.data<span class="sc">$</span>clones_to_plot <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">2</span>]]<span class="sc">@</span>meta.data<span class="sc">$</span>clones_to_plot[<span class="fu">which</span>(vgm[[<span class="dv">2</span>]]<span class="sc">$</span>clonotype_id_10x <span class="sc">%in%</span> interesting_clones)] <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>plot_out <span class="ot">&lt;-</span> <span class="fu">VDJ_GEX_overlay_clones</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">clones.to.plot =</span> <span class="st">&quot;clones_to_plot&quot;</span>, <span class="at">by.sample =</span> F, <span class="at">ncol.facet =</span> <span class="dv">1</span>, <span class="at">split.plot.and.legend =</span> T, <span class="at">pt.size =</span> <span class="fl">0.5</span>)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>plot_out[[<span class="dv">1</span>]] <span class="co"># the plot</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(plot_out[[<span class="dv">2</span>]]) <span class="co"># the legend. Alternatively use gridExtra::grid.arrange(plot_out[[2]])</span></span></code></pre></div>
</div>
<div id="specific-gene-expression-information-on-the-clonal-level" class="section level3">
<h3>8.4 Specific gene expression information on the clonal level</h3>
<p>We previously integrated the GEX information into the format of the
VDJ output. However, we may want to ask how the gene expression looks
for certain clonotypes (e.g., how many of the cells in the top clone are
expressing markers of activated B cells). This is done by adding an
extra column to the expanded clones and examining transcritional
differences to cells of non expanded clones</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">2</span>]]<span class="sc">$</span>Expanded <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>vgm[[<span class="dv">2</span>]]<span class="sc">$</span>Expanded[<span class="fu">which</span>(vgm[[<span class="dv">2</span>]]<span class="sc">$</span>clonotype_frequency <span class="sc">&gt;</span> <span class="dv">1</span>)] <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(vgm[[<span class="dv">2</span>]]<span class="sc">$</span>Expanded)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">#We can use the dottile function to look at selected genes</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="fu">GEX_dottile_plot</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">genes =</span> <span class="fu">c</span>(<span class="st">&quot;CD19&quot;</span>, <span class="st">&quot;CD74&quot;</span>,<span class="st">&quot;IL2RA&quot;</span>, <span class="st">&quot;CD27&quot;</span>,<span class="st">&quot;CD80&quot;</span>), <span class="at">group.by =</span> <span class="st">&quot;Expanded&quot;</span>, <span class="at">threshold.to.plot =</span> <span class="dv">1</span>) <span class="sc">+</span> ggplot2<span class="sc">::</span><span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)</span></code></pre></div>
<p>For a more unbiased view, DEGs can be calculated between expanded and
non-expanded clones</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>DE_byexpansion <span class="ot">&lt;-</span> <span class="fu">GEX_DEgenes</span>(<span class="at">GEX =</span> vgm[[<span class="dv">2</span>]], <span class="at">min.pct =</span> <span class="fl">0.25</span>, <span class="at">group1 =</span> <span class="st">&quot;TRUE&quot;</span>, <span class="at">group2 =</span> <span class="st">&quot;FALSE&quot;</span>, <span class="at">grouping.column =</span> <span class="st">&quot;Expanded&quot;</span>, <span class="at">return.plot =</span> <span class="st">&quot;volcano&quot;</span>, <span class="at">label.n.top.genes =</span> <span class="dv">10</span>, <span class="at">platypus.version =</span> <span class="st">&quot;v3&quot;</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(DE_byexpansion[[<span class="dv">1</span>]])</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>DE_byexpansion[[<span class="dv">2</span>]]</span></code></pre></div>
<p>Indeed inflammation associated markers as well as MHC clomplex
components are upregulated in expanded clones.</p>
</div>
</div>
<div id="version-information" class="section level2">
<h2>9 Version information</h2>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code></pre></div>
<pre><code>## R version 4.2.1 (2022-06-23 ucrt)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 19044)
##
## Matrix products: default
##
## locale:
## [1] LC_COLLATE=C                    LC_CTYPE=German_Germany.utf8
## [3] LC_MONETARY=German_Germany.utf8 LC_NUMERIC=C
## [5] LC_TIME=German_Germany.utf8
##
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base
##
## other attached packages:
## [1] Platypus_3.3.6
##
## loaded via a namespace (and not attached):
##   [1] plyr_1.8.7             igraph_1.3.4           lazyeval_0.2.2
##   [4] sp_1.5-0               splines_4.2.1          listenv_0.8.0
##   [7] scattermore_0.8        usethis_2.1.6          GenomeInfoDb_1.32.2
##  [10] ggplot2_3.3.6          digest_0.6.29          useful_1.2.6
##  [13] yulab.utils_0.0.5      htmltools_0.5.3        fansi_1.0.3
##  [16] magrittr_2.0.3         memoise_2.0.1          tensor_1.5
##  [19] cluster_2.1.3          ROCR_1.0-11            remotes_2.4.2
##  [22] globals_0.15.1         Biostrings_2.64.0      matrixStats_0.62.0
##  [25] spatstat.sparse_2.1-1  prettyunits_1.1.1      colorspace_2.0-3
##  [28] ggrepel_0.9.1          xfun_0.31              dplyr_1.0.9
##  [31] callr_3.7.1            crayon_1.5.1           RCurl_1.98-1.7
##  [34] jsonlite_1.8.0         roxygen2_7.1.1         spatstat.data_2.2-0
##  [37] progressr_0.10.1       survival_3.3-1         zoo_1.8-10
##  [40] ape_5.6-2              glue_1.6.2             polyclip_1.10-0
##  [43] gtable_0.3.0           zlibbioc_1.42.0        XVector_0.36.0
##  [46] leiden_0.4.2           seqinr_4.2-16          pkgbuild_1.3.1
##  [49] future.apply_1.9.0     BiocGenerics_0.42.0    abind_1.4-5
##  [52] scales_1.2.0           DBI_1.1.3              spatstat.random_2.2-0
##  [55] miniUI_0.1.1.1         Rcpp_1.0.9             viridisLite_0.4.0
##  [58] xtable_1.8-4           spatstat.core_2.4-4    gridGraphics_0.5-1
##  [61] tidytree_0.3.9         reticulate_1.25        stats4_4.2.1
##  [64] profvis_0.3.7          htmlwidgets_1.5.4      httr_1.4.3
##  [67] RColorBrewer_1.1-3     ellipsis_0.3.2         Seurat_4.1.1
##  [70] ica_1.0-3              urlchecker_1.0.1       pkgconfig_2.0.3
##  [73] sass_0.4.2             uwot_0.1.11            deldir_1.0-6
##  [76] utf8_1.2.2             ggplotify_0.1.0        tidyselect_1.1.2
##  [79] rlang_1.0.4            reshape2_1.4.4         later_1.3.0
##  [82] munsell_0.5.0          tools_4.2.1            cachem_1.0.6
##  [85] cli_3.3.0              generics_0.1.3         ade4_1.7-19
##  [88] devtools_2.4.4         ggridges_0.5.3         evaluate_0.15
##  [91] stringr_1.4.0          fastmap_1.1.0          yaml_2.3.5
##  [94] goftest_1.2-3          ggtree_3.4.1           processx_3.7.0
##  [97] knitr_1.39             fs_1.5.2               fitdistrplus_1.1-8
## [100] purrr_0.3.4            RANN_2.6.1             pbapply_1.5-0
## [103] future_1.27.0          nlme_3.1-157           mime_0.12
## [106] aplot_0.1.6            xml2_1.3.3             compiler_4.2.1
## [109] rstudioapi_0.13        plotly_4.10.0          png_0.1-7
## [112] spatstat.utils_2.3-1   treeio_1.20.1          tibble_3.1.8
## [115] bslib_0.4.0            stringi_1.7.8          ps_1.7.1
## [118] desc_1.4.1             rgeos_0.5-9            lattice_0.20-45
## [121] Matrix_1.4-1           vctrs_0.4.1            pillar_1.8.0
## [124] lifecycle_1.0.1        jquerylib_0.1.4        spatstat.geom_2.4-0
## [127] lmtest_0.9-40          RcppAnnoy_0.0.19       data.table_1.14.2
## [130] cowplot_1.1.1          bitops_1.0-7           irlba_2.3.5
## [133] httpuv_1.6.5           patchwork_1.1.1        R6_2.5.1
## [136] promises_1.2.0.1       gridExtra_2.3          KernSmooth_2.23-20
## [139] IRanges_2.30.0         parallelly_1.32.1      sessioninfo_1.2.2
## [142] codetools_0.2-18       MASS_7.3-57            assertthat_0.2.1
## [145] pkgload_1.3.0          rprojroot_2.0.3        withr_2.5.0
## [148] SeuratObject_4.1.0     sctransform_0.3.3      S4Vectors_0.34.0
## [151] GenomeInfoDbData_1.2.8 mgcv_1.8-40            parallel_4.2.1
## [154] rpart_4.1.16           grid_4.2.1             ggfun_0.0.6
## [157] tidyr_1.2.0            rmarkdown_2.14         Rtsne_0.16
## [160] shiny_1.7.2</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
