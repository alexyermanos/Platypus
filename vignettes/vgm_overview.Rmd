---
title: "Platypus VDJ_GEX_matrix"
author: "Alexander Yermanos, Victor Kreiner, Andreas Agrafiotis"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Platypus VDJ_GEX_matrix}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
fig_width: 16
fig_height: 16
---

```{r setup, include=FALSE, eval = TRUE}
#to avoid of the dplyr summarise warnings
library(dplyr, warn.conflicts = FALSE)
options(dplyr.summarise.inform = FALSE)
library(stats, warn.conflicts = F)
knitr::opts_chunk$set(fig.width=7, fig.height=7) 
library(tidyverse)
library(Seurat)
library(Platypus)

# REMOVE FOR FINAL VIGNETTE ONCE BUGFIX IS ON CRAN 
#source("~/GitHub/Platypus/R/VDJ_GEX_matrix.R")
```

## 1. VGM Introduction

The VGM is the central data object of the current iteration of Platypus that is produced by the VDJ_GEX_matrix function. The main idea was to create a single object that contains all relevant immune information that can be supplied to all other functions in our package. This additionally provides the benefit that in the case of custom data formats (e.g. pre-existing Seurat objects or non 10x single-cell repertoire information), the user can adapt the necessary column names and still use the downstream functions of Platypus. 

For downstream examples of how the VGM interacts with other Platypus functions, please refer to the Platypus Quickstart vignette. This vignette will describe how we create the VGM from the output of 10x genomics cellranger and how this can be modulated by the various fucntion arguments.

As the function processes both GEX and VDJ, this vignette is devided into 3 parts: 
2. General settings
3.1 Gene expression (GEX)
3.2. Feature Barcodes (FB)
4. Immune receptor repertoire (VDJ)

Most examples use the yermanos2021a dataset from PlatypusDB, which contains B and T cells (GEX + VDJ) and is also featured in the quickstart vignette due to the low number of cells. For more information, please refer to the corresponding publication: https://doi.org/10.1098/rspb.2020.2793 

## 2. General Information

### 2.1 Input formats

The VGM takes three different input formats that will be covered in the respective sections:
1. Local Paths to cellranger output files (covered below)
2. Data.in list input from either PlatypusDB_fetch() or PlatypusDB_load_from_disk() (covered in the PlatypusDB vignette) This is for the case where a user would like to download raw PlatypusDB datasets and integrate these with local data.
3. A processed Seurat object as Seurat.in (Covered in section 3.1.4) This is for the case that a user would like to use an existing seurat object, which may be desired when using custom normalization and integration methods for GEX data. 

Local paths should be provided to cellranger directories which...
...for GEX: Corresponds to the "outs" folder from cellranger count function. Under default parameters, the directory supplied as input to the VGM function should contain the filtered_feature_annotations folder from 10x cellranger count. 
...for VDJ: Corresponds to the "outs" folder from the cellranger vdj function. Under default parameters, the directory supplied as input to the VGM function should contain files such as clonotypes.csv 10x cellranger vdj. 

Below is an example of a basic run. The user will need to change the input directory to their own local output files from cellranger.

```{r, fig.show='hold', message=FALSE,results = 'hide', eval = TRUE}

#Creating a list with local paths to cellranger directories

VDJ.out.directory.list <-  
        list("C:/Users/PlatypusDB/yermanos2021b__VDJ_RAW/Aged.CNS.pool.3m.Bcell.S1",                     "C:/Users/PlatypusDB/yermanos2021b__VDJ_RAW/Aged.CNS.pool.12m.Bcell.S2")
GEX.out.directory.list <- 
        list("C:/Users/PlatypusDB/yermanos2021b__GEX_RAW/Aged.CNS.pool.3m.Bcell.S1",                     "C:/Users/PlatypusDB/yermanos2021b__GEX_RAW/Aged.CNS.pool.12m.Bcell.S2")


#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,
                      GEX.out.directory.list = GEX.out.directory.list,
                      verbose = T) #For more detailed runtime messages

```

The function can also be run with just GEX or VDJ input. 
The output object will have the same format as if both GEX and VDJ folders were supplied as input to ensure compatibility with all downstream functions.
If this is needed, please provide only the desired input

```{r, fig.show='hold', eval = FALSE}

#Only VDJ run
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list) 

#Only GEX run
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list) 

```

## 2.2 Output format

Irregardless of the input, the output format stays the same. This allows compatibility with all other downstream Platypus as well as custom functions. 

```{r, fig.show='hold', eval = TRUE}

names(vgm)

```
The VGM output is a list of 5 elements as seen above.
Certain downstream functions may add additional list elements but will always maintain the first 5.

VDJ is a data.frame with standard column output

```{r, fig.show='hold', eval = TRUE}

head(vgm[[1]])

```

The GEX object vgm[[2]] is a Seurat object. Metadata can be accessed as shown below. 
Depending on integration parameters (Section 2.3), the GEX object can also contain information from the immune receptor VDJ data. 

```{r, fig.show='hold', eval = TRUE}

Seurat::DimPlot(vgm[[2]])

names(vgm[[2]]@meta.data)

```

VDJ.GEX.stats is a table containing statistics about the processed datasets. 
This is useful for QC. Many of the values in this dataframe are imported from the metrics.csv tables provided by Cellranger. In case these tables are not available, the output will contain NA values. 

The generation of this table can be toggled by setting get.VDJ.stats = F

```{r, fig.show='hold', eval = TRUE}

names(vgm[[3]])

```

```{r, fig.show='hold', eval = FALSE}

vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,
                      GEX.out.directory.list = GEX.out.directory.list,
                      get.VDJ.stats = F) #Turn off VDJ stats 

```

The VGM also stores the parameter used during function call in case a user saves a VGM but deletes/overwrites the initial code....although this should not happen...right?

When the VGM is called under default parameters, the function input arguments can be located in the fourth list element. 

```{r, fig.show='hold', eval = TRUE}

vgm[[4]]

```

The fifth element of the VGM  contains the utils::sessionInfo() output to record the versions of R and accompanying packages used during the VGM creation.

```{r, fig.show='hold', eval = TRUE}

class(vgm[[5]])

```

## 2.3 Parameters for VDJ GEX integration

A key feature of Platypus is the direct pairing of VDJ and GEX data. 
This is currently achieved by VGM combining the relevant data and metadata from VDJ (vgm[[1]]) and GEX (vgm[[2]]) objects using the cell barcode and sample_id information.  
Several parameters control this integration: 

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,
                      GEX.out.directory.list = GEX.out.directory.list,
                      VDJ.combine = T, #Whether to combine all samples into one VDJ dataframe (is highly recommended)
                      GEX.integrate = T, #Whether to integrate all GEX samples. For integration methods see GEX section.  
                      integrate.GEX.to.VDJ = T, #Whether to copy GEX metadata into VDJdataframe 
                      integrate.VDJ.to.GEX = T, #Whether to copy VDJ data into GEX
                      exclude.GEX.not.in.VDJ = F) #Whether to exclude cells in GEX, for which no VDJ data is available. Set this to TRUE if you only want gene expression information for those cells with immune receptor sequences.
                      
```

In some cases, cell barcodes may not be unique across samples. This may occur by pure chance, barcode hopping during library construction and sequencing, or due to low diversity of barcodes during capture. The VGM deals with this in two ways. Firstly, a sample-id prefix is appended to every barcode.  

```{r, fig.show='hold', eval=TRUE}

vgm[[1]]$barcode[1]

colnames(vgm[[2]])[1]

```
Second, the duplicated barcodes can be filtered out to prevent the emergence of unlikely public clones. This is necessary, for example, if a public clone is discovered in two distinct VDJ samples and have the exact same cell barcode. Public clones containing identical cell barcodes are highly unlikely given the massive potential barcode space. If this filtering is set to TRUE, the function will prompt a callback with the number of filtered cells.

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,
                      GEX.out.directory.list = GEX.out.directory.list,
                      filter.overlapping.barcodes.GEX = T,
                      filter.overlapping.barcodes.VDJ = T) 
                      
```

## 3.1 GEX 

The VGM function attempts to simplify the standard GEX processing and integration functions common to Seurat and Harmony packages, given the majority of immunological studies use this pipeline. Although we are not making the statement that all gene expression datasets should be processed using identical parameters, we find that this function simplifies the standard copy-paste from the Seurat website. 

### 3.1.1 GEX QC filtering parameters

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list, 
                      VDJ.gene.filter = T, #Remove all VDJ genes from GEX before clustering.
                      mito.filter = 20, #Remove all cells with a higher % of reads mapped to Mitochondiral genes. Data gathered via Seurat::PercentageFeatureSet(., pattern = "^MT-")
                      n.count.rna.min = 0, #Remove all cells with a total RNA count below this
                      n.count.rna.max = Inf,  #Remove all cells with a total RNA count above this
                      n.feature.rna = 0) #Remove all cells with a gene count lower than this
```

The default settings are meant to be inclusive, so to not impose filtering to on the dataset which is not directly apparent to the user. 

### 3.1.2 GEX filtering by phenotype 

The VGM also offers the option to filter cells based on their gene expression profiles. Removing unwanted cells before clustering can result in more accurate conclusions concerning the cell types of interest. For example, it is likely better to filter out non B and T cells if integrating and analyzing repertoire features such as clonal expansion. 

The input format for the exclude.on.cell.state.markers argument is the same as to the GEX_phenotype function. 
In the example below, we filter out all CD14 positive cells as well as all CD3 epsilon and gamma double negative cells.

```{r, fig.show='hold', message=FALSE, eval = TRUE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list, 
                      exclude.on.cell.state.markers = c("CD14+", "CD3E-;CD3G-")) #Remove all cells with a total RNA count above this
                      
#Plotting this confirms the filtering 
Seurat::FeaturePlot(vgm[[2]], c("CD14","CD3E","CD3G"))

```

As a workflow we first recommend clustering all cells and running a differential gene expression analysis by cluster using the GEX_cluster_genes() function, which reveals the cluster-defining genes of each cluster.
In case that unwanted cells are present (e.g. a contamination of Neutrophils in a B cell dataset), the cluster signatures can be used to identify the best genes for filtering via the initial VGM call. 

### 3.1.3 GEX integration methods

The VGM offers four methods of GEX dataset integration if GEX.integrate is set to TRUE: 

1."scale.data" integration is based on Seurat logNormalize followed by the ScaleData function based on found variable features (set using n.variable.features)

2. "anchors" is an integration method which uses similar cell states to align to datasets. Extensive documentation is provided here: https://satijalab.org/seurat/articles/integration_introduction.html

3. "sct" employs the SCTransform function from Seurat

4. "harmony" uses the Bioconductor package Harmony. This may be better for larger datasets given the runtime and required memory of anchors and sct.

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list,
                      GEX.integrate = T, 
                      integration.method = "scale.data") #Default

BiocManager::install("harmony")

vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list,
                      GEX.integrate = T, 
                      integration.method = "harmony")

```

### 3.1.3 GEX clustering optimisation parameters

Indipendently of integration method, GEX data is scaled and variable features and PCA dimensions are used to calculate low dimensional embedding 
Three parameters control these: 

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list,
                      GEX.integrate = T, 
                      integration.method = "scale.data", #Default
                      norm.scale.factor = 10000, #passed to Seurat::NormalizeData
                      n.variable.features = 2000, #Passed to Seurat::FindVariableFeatures
                      cluster.resolution = 0.5, #Passed to Seurat::FindClusters
                      neighbor.dim = c(1:10), #Passed to Seurat::FindNeighbors
                      mds.dim = c(1:10)) #Passed to Seurat::RunTSNE and Seurat::RunUMAP

```

### 3.1.4 Input a processed Seurat object

The VGM offers simple and flexible GEX processing, but remains one of many options for GEX processing. 
We therefore made it possible to use the VDJ processing and VDJ-GEX integration capabilities of the VGM function with an already processed Seurat object. 

For a Seurat object to be compatible as input, it must contain two metadata columns: 
1. sample_id with sample ids from s1,s2,s3 to sn of character or factor class. These must be in the same order as VDJ.out.directory list elements.
2. group_id of character class. 

This input Seurat object will not be processed concerning normalisation or dimensional embeddings.
Nonetheless the following filtering operations are still available, as shown below

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running the VDJ_GEX_matrix function
vgm <- VDJ_GEX_matrix(Seurat.in = preprocessed_GEX, 
                      exclude.GEX.not.in.VDJ = F, 
                      integrate.GEX.to.VDJ = T, 
                      integrate.VDJ.to.GEX = T, 
                      filter.overlapping.barcodes.GEX = T, 
                      exclude.on.cell.state.markers = c("CD3E+")
                      GEX.integrate = T) 

```

### 3.2.1 Feature Barcode import

Platypus supports feature barcode technology (also referred to as hashing barcodes), but at this time does not support CITE-seq data. (This is on the Platypus-Team To-Do list)

Feature Barcode (FB) data may be imported in two different modes, depending on Cellranger processing proceedures. 

1. FB data processed indipendently of GEX data via Cellranger count will yield an output folder structure which is identical to GEX. These output directories can be fed into the VGM using the FB.out.directory.list

2. FB data can also be processed in combination with GEX using Cellranger multi and aggr. This yields a single folder structure with both GEX and FB matrices contained within the same output files. In this case, the function will determine the input type (GEX of FB) of each matrix based on the numbers of Features. Any matrix below 100 features is regarded FB and every matrix above that as GEX. 

```{r, fig.show='hold', message=FALSE, eval = FALSE}

FB.out.directory.list <-  
        list("~path_to_CellrangerCount_outs_directory",                   
             "~path_to_CellrangerCount_outs_directory")

#Running with separate FB input
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list,
                      FB.out.directory.list = FB.out.directory.list) 

#Running with FB GEX combined input
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.cellranger.aggr.out.directory.list)

```

### 3.2.2 Feature Barcode assignment

The concept of feature barcodes lies in the attribution of a certain sample or group barcode to a cell given the number of sequenced counts of that barcode. 
While this does work well in most cases, FB data can be noisy and a subset of cells may be difficult to confidently attribute to a single barcode. 
The VGM assignes FBs to cells by two criteria: 

1. FB.count.threshold determines how many counts for any FB are neccessary to be considered. This defaults to 10. For example, in case a cell has counts < 10 for all FBs, no single FB will be assigned (Function returns "Not assignable").

2. FB.ratio.threshold determines the minimum ratio between the most frequent and second most frequent FB for the most frequent to be confidently assigned. This defaults to 2. 
For clarity we can consider the following example

<table>
  <tr>
    <th>barcode</th>
    <th>FB-1</th>
    <th>FB-2</th>
    <th>FB-3</th>
  </tr>
  <tr>
    <td>Cell 1</td>
    <th>3</th>
    <th>4</th>
    <th>9</th>
  </tr>
  <tr>
    <td>Cell 2</td>
    <th>1</th>
    <th>32</th>
    <th>43</th>
  </tr>
    <tr>
    <td>Cell 3</td>
    <th>100</th>
    <th>1</th>
    <th>13</th>
  </tr>
</table>


For Cell 1: 9/4 > 2, so FB-3 meets the FB.ratio.threshold. But: 9 < 10 so FB-3 does not meet the FB.count.threshold. For this cell the function returns "Not assignable"

For Cell 2: 43 and 32 > 10 so both FB-2 and FB-3 meet the FB.count.threshold. But: 43/32 < 2 so FB-3 does not meet the FB.ratio.threshold. Again the function returns "Not assignable"

For Cell 3: 100 > 10 and 100/32 > 2 so FB-1 meets both criteria. The function returns "FB-1"

Tweaking these parameters can help to make barcode assignments more inclusive, but also more susceptible to false assignments. 

As a QC, we recommend verifying that variability in FB coverage across libraries and samples is consistent and that FB assignments match with expected numbers from e.g. pre-sorting by FACS. 

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running with separate FB input
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list,
                      FB.out.directory.list = ,
                      FB.count.threshold = 10, 
                      FB.ratio.threshold = 2) 

#Running with FB GEX combined input
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.cellranger.aggr.out.directory.list)

```

### 3.2.3 Feature Barcode filtering

In many cases, hashing barcodes are being combined with CITE-seq or other surface barcodes. 
For processing FB barcodes, all other barcodes need to be filtered out. 
For this the VGM allows excluding Feature barcodes by their names and a regex expression. 
In the example below we are filtering out all FBs that have "CITE" or "TetTCR" in their name. 

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#Running with separate FB input
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.out.directory.list,
                      FB.out.directory.list = , 
                      FB.exclude.pattern = "(CITE|TetTCR)") 

#Running with FB GEX combined input
vgm <- VDJ_GEX_matrix(GEX.out.directory.list = GEX.cellranger.aggr.out.directory.list)

```

## 4.1. VDJ 

The VGM allows to reformat and merge several dataframes from Cellranger outputs and additionally return aligned and trimmed receptor sequences. 

```{r, fig.show='hold', message=FALSE, eval = TRUE}

#Basic run with VDJ only
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list) 

```

### 4.1.1 Accomodating cells with aberrant chain numbers

Due to stochastical sampling, inter-cellular mRNA and biological peculiarities, a single cell barcode may be associated with one, two or more TCR or BCR contigs. 
A classical cell contains 1VDJ and 1VJ chain. Cells with only one chain are frequent, while chains with more than 2 are rare. 

The VGM function and format is fully compatible with any combination of chains, without the need for cell filtering. 
Fields attributed to a missing chain will contain and empty string (""). In fields which contain information about 2 chains (e.g. VDJ_cdr3_aa in a cell with 2VDJ chains) different chains are separated by ";"

For filtering purposes two numeric columns containing the number of chains are included

```{r, fig.show='hold', message=FALSE, eval = TRUE}

head(subset(vgm[[1]], Nr_of_VJ_chains == 0))

head(subset(vgm[[1]], Nr_of_VJ_chains == 2))

```

### 4.1.2 Filtering chains by UMI counts

While filtering out all cells with aberrant chain numbers is often used during processing of VDJ data, Platypus offers a format which can accomodate and integrate these cells into analysis. (See VDJ_clonotype_v3()).
A third option was proposed by Zhang W et al. (Sci Adv. 2021 10.1126/sciadv.abf5835): To choose between excess chains, by the count of unique molecular identifier of each contig (UMIs). 
The VGM function implements this strategy with two parameters: 
1. select.excess.chains.by.umi.count Is a boolean. Once set to TRUE the VGM will filter excess chains based on UMI count

2. excess.chain.confidence.count.threshold is an integer that allows to tweak filtering. It defaults to 1000 (any large value would achive the same). To illustrate the filtering behavior we can consider the following example with cells having 2 VJ chains


select.excess.chains.by.umi.count = T

<table>
  <tr>
    <th>barcode</th>
    <th>Nr_of_VJ_chains</th>
    <th>VJ_UMIs</th>
  </tr>
  <tr>
    <td>Cell 1</td>
    <td>2</td>
    <td>1;1</td>
  </tr>
  <tr>
    <td>Cell 2</td>
    <td>2</td>
    <td>1;5</td>
  </tr>
    <tr>
    <td>Cell 3</td>
    <td>2</td>
    <td>3;3</td>
  </tr>
</table>

FOR: excess.chain.confidence.count.threshold = 1000

Cell 1 -> both chains are below the threshold and are therefore subject to filtering. Given that both chains have the same UMI count, a one contig is eliminated at random. 
Cell 2 -> both chains are below the threshold and subject to filtering. Chain 2 has the higher UMI and is therefore kept
Cell 3 -> proceeds as for Cell 1

FOR: excess.chain.confidence.count.threshold = 3

Cell 1 -> same as above
Cell 2 -> chain 1 is below threshold and subject to filtering. Chain 2 is above threshold and therefore considered a high confidence chain and not filtered
Cell 3 -> Both chains are equal or above threshold, both are considered high confident and no chain is filtered. 

UMI distribution within VDJ datasets can vary. To optimize this filtering parameter we recommend investigating UMI frequencies in cells with double chains.

```{r, fig.show='hold', message=FALSE, eval = FALSE}

vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,
                      select.excess.chains.by.umi.count = T,
                      excess.chain.confidence.count.threshold = 1000) 

```

## 4.2 VDJ trimming and aligning and translating

It may be useful to obtain full-length sequences (e.g., for phylogenetics or experimental expression and validation, see Pogson M. et al. Nat Comm. 2016, 10.1038/ncomms12535) from single-cell sequencing data. We have therefore added an option to recover both trimmed and untrimmed sequences as determined by the cellranger vdj function. If the user sets the trim.and.align parameter to TRUE, this will return processed VDJ contig strings as detailed below: 

1. Trimming: The raw nt contig sequences are trimmed to the start of the V segment and the end of the J segment. (VDJ/VJ_sequence_nt_trimmed)
These trimmed sequences contain signal peptide information. In the case that a user does not want this, we currently use MIXCR to realign and extract the sequence that spans FR1 to FR4 for both heavy and light chains. This can be done using the VDJ_call_MiXCR() function within Platypus, although it does require the user to download mixcr locally. 

2. Translation: The trimmed contigs are translated to yield full amino acid sequences. (VDJ/VJ_sequence_aa)

3. Realigning to reference: 
The untrimmed germline sequences (as determined by 10x genomics) for each clonotype consensus sequence are returned are returned when trim.and.align = T. This can be used on IMGT or with MIXCR to further provide a shorter reference sequence that covers just the FR1 to FR4. 
Furthermore the function aligns trimmed contig sequences to reference contigs using Biostrings::pairwiseAlignment with alignment = "local"; see optimization parameters in section 4.1.2). This results in a reference sequence from the start of the V segment to the end of the J segment. (VDJ/VJ_trimmed_ref)
Most of the time this trimmed germline sequence will be out of frame given the CDR3 deletions and insertions. In the case that a user wants an in-frame germline (e.g. for expression), the CDR3 will likely need to be replace. We are currently developing a pipeline that supplies CDR3s of those recovered sequences that are closest to germline - so stay tuned :)

The trimmed contigs are aligned to the sequences of the  concat_ref.fasta file and the reference is trimed accordingly. 
(This is done using: Biostrings::pairwiseAlignment with alignment = "local"; see optimization parameters in section 4.1.2)

```{r, fig.show='hold', message=FALSE, eval = TRUE}

vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list, 
                      trim.and.align = T) 

vgm[[1]][1,c("VDJ_sequence_nt_raw", "VDJ_sequence_nt_trimmed", "VDJ_sequence_aa", "VDJ_trimmed_ref")]

```
### 4.2.1 Optimizing parameters of VDJ aligning

A key difficulty of TCR and BCR sequences, is that CDR3-containing junction regions almost never matches known references. This leaves alignment gaps and can lead to the highest scoring alignment to not contain the junction-following J segment. 
The VGM therefore allows to tweak the alignment parameters gap.opening.cost and gap.extension.cost

```{r, fig.show='hold', message=FALSE, eval = FALSE}

vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list, 
                      trim.and.align = T, 
                      gap.opening.cost = 10, 
                      gap.extension.cost = 4) 

```

### 4.2.2 Optimizing alignment runtime

To accelerate alignment the VGM allows for multicore processing via the functions mclapply or parlapply depending on the operating system from the Parallel package. Given initiation times of multicore processes, we only recommend using it for datasets with >2000 cells. 

The parameter numcores can be used to set the number of cores used. This defaults to all available cores, therefore, setting a limit when running the function on a cluster is crucial. 

By default parallel.processing is set to "none" and the function uses standard lapply

```{r, fig.show='hold', message=FALSE, eval = FALSE}

#For LINUX and WINDOWS users
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list, 
                      trim.and.align = T, 
                      parallel.processing = "parlapply",
                      numcores = 8) 

#For MAC users
vgm <- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list, 
                      trim.and.align = T, 
                      parallel.processing = "mclapply",
                      numcores = 8) 

```

## 5. Conclusion

We hope that this comprehensive vignette of the VGM function enables any user to employ the full functionality of this function.
If you have any issues, requests or ideas concerning existing or new features, please reach out to us via Github or Email. 

## 6. Version information

```{r, fig.show='hold'}
sessionInfo()
```

