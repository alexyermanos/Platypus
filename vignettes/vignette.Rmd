---
title: "Platypus vignette"
author: "Alexander Yermanos"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Platypus vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Introduction

Platypus is a package designed to facilitate the analysis of single-cell immune repertoire sequencing experiments. The package can be used to separately analyze gene expression (GEX) or immune receptor repertoire (VDJ) sequencing data, in addition to integrating the two data sets to combine phenotypic features with repertoire analysis. The package is designed to primarily analyze the output from 10x genomics cellranger (output from count for GEX and VDJ for enriched immune receptor libraries). The functions could work with other barcode-based scSeq technologies assuming the input columns are added correctly. The gene expression analysis relies heavily upon Seurat, a commonly used R package for single-cell sequencing (scSeq). 


## 2. Gene expression analysis

The output from cellranger's count function returns gene expression information in the form of an expression matrix, barcodes, and gene identifiers. The function automate_GEX allows us to automate the transcriptional analysis of the gene expression libraries from cellranger. The input directory should be set to the directory containing these three files: barcodes.tsv.gz, features.tsv.gz, matrix.mtx.gz. If it is desired to analyze multiple distinct transcriptomes (e.g., on separate UMAP space), these directories should go into separate list objects. For example, if there are 20 repertoires and it is wanted to analyze them separately (20 separate UMAPs, 20 separate repertoires) then each outer list element of the input directories will contain the directory for the individual repertoire/GEX files. The output of this function is a Seurat object similar to the standard pipeline demonstrated in the Seurat vignette. This involves scaling, normalizing, clustering, and performing dimensionality reduction (tSNE and UMAP by default). At this stage, there is no incorporation of repertoire features, which need to be explicitly integrated using subsequent functions in Platypus.

In the example below two directories are supplied to two distinct list elements, and thus these distinct transcriptomes (corresponding to two distinct repertoires) will each be associated to a distinct Seurat object.
```{r, fig.show='hold', message=FALSE}

### Removing any previous versions of the package
#First, ensure there is no previous version installed locally
#detach("package:Platypus", unload=TRUE)
#remove.packages("Platypus")

### Downloading and installing Platypus

# Download most recent version from master branch at https://github.com/alexyermanos/Platypus We can install the package using the following command. 
# WARNING: This needs to be replaced with your own directory where the downloaded package is found

# For MacOS users it may look like this:
#install.packages("~/Downloads/Platypus_2.0.5.tar.gz", repos = NULL, type="source")

# For windows it will likely look something like this: 
# WARNING: You will need to replace 'YourPCName' with your user name for the windows account in the directory. 
# install.packages("C:\Users\YourPCName\Downloads\Platypus_2.0.4.tar.gz", repos = NULL, type="source")

# Now we can load the installed package into the R environment. In case of problems with installing other R packages that are used in Platypus, please see the README file at the https://github.com/alexyermanos/Platypus, where we outline how to install the other R packages for both Windows and MacOS.
library(Platypus)

# Individual R functions can additionally be found on the github Functions branch. Within this branch, there is a folder "R" which contains the individual functions. This can similarly be downloaded and loaded into the R environment in case not all functions are desired. These functions are actively updated and may include more features than the in original tar.gz file. 


### Downloading the test data
# The COVID-19 data (~136 MB size of the zip file) can be found at the following link https://polybox.ethz.ch/index.php/s/fxQJ3NrRSwiPSSo This dataset contains VDJ (separate libraries for B and T cells) and GEX libraries from two convalescent COVID-19 patients.

# After downloading the zip file named "PlatypusTestData.zip", please unzip the file and find the path to the newly formed folder. Typically this will be in the Downloads folder, so the code below should work on MacOS. For Windows please uncomment the code and change the user name to match your PC.

directory_to_covid_patients_gex <- list()
directory_to_covid_patients_gex[[1]] <- c("~/Downloads/PlatypusTestData/Patient1_GEX/")
directory_to_covid_patients_gex[[2]] <- c("~/Downloads/PlatypusTestData/Patient2_GEX/")

# For Windows: 
#directory_to_covid_patients_gex[[1]] <- c("C:\Users\YourPCName\Downloads\PlatypusTestData\Patient1_GEX")
#directory_to_covid_patients_gex[[2]] <- c("C:\Users\YourPCName\Downloads\PlatypusTestData\Patient2_GEX")


```

GEX_automate allows us to perform the standard Seurat pipeline in a single line of code with the ability to change the parameters used by Seurat involving minimum read numbers, mitochondrial gene percentages, cluster resolution, etc. In addition, we can remove antibody and TCR genes from the data set (e.g. IGHV1-1) to not let clonality impact transcriptional clustering by simply setting the VDJ.gene.filter argument to TRUE.
```{r, fig.show='hold', message=FALSE}

covid_gex_patients_not_integrated <- Platypus::GEX_automate(GEX.outs.directory.list = directory_to_covid_patients_gex,integration.method = "scale.data",mito.filter = 20,cluster.resolution = 0.5,VDJ.gene.filter = T)

```

Based on the input given (2 directories as separate list objects), we get 2 distinct Seurat objects.
```{r, fig.show='hold'}
length(covid_gex_patients_not_integrated) ## length of two 
class(covid_gex_patients_not_integrated) ## output is a list
class(covid_gex_patients_not_integrated[[1]]) ## Seurat object 
ncol(covid_gex_patients_not_integrated[[1]]) ## 6871 cells
ncol(covid_gex_patients_not_integrated[[2]]) ## 6055 cells

```

Now we can visualize the 2D plots for each patient individually. By default, UMAP, PCA, and TSNE reductions are included in the object. Under default parameters this will display all cells in the GEX library from Patient1. By changing to the second list element we can view the cells from Patient2.
```{r, fig.show='hold'}
Seurat::DimPlot(covid_gex_patients_not_integrated[[1]],reduction = "umap")

Seurat::DimPlot(covid_gex_patients_not_integrated[[1]],reduction = "pca")

Seurat::DimPlot(covid_gex_patients_not_integrated[[1]],reduction = "tsne")

# UMAP for the second patient
Seurat::DimPlot(covid_gex_patients_not_integrated[[2]],reduction = "umap")

```

If we are intrested in merging the transcripotmes (corresponding to two distinct gene expression libraries), then the two directories are supplied to a single list element. The output from GEX_automate (corresponding to a single Seurat object list element this time) contains a column with the sample origin information based on the order of the input directories. Additionally, one can label different samples by group in the case that biological replicates are present. In this case we simply set patients to group1 and group2 
```{r, fig.show='hold',message=FALSE}
directory_to_covid_patients_integrated <- list()
directory_to_covid_patients_integrated[[1]] <- c("~/Downloads/PlatypusTestData/Patient1_GEX/",
                                                 "~/Downloads/PlatypusTestData/Patient2_GEX/")

## Here we use the previous version of automate_GEX to produce the identical UMAP seen in the manuscript. 
covid_gex <- Platypus::automate_GEX(GEX.outs.directory.list = directory_to_covid_patients_integrated[1:1],integration.method = "scale.data",mito.filter = 20,cluster.resolution = 0.5,VDJ.gene.filter = T)

### In this case, patient1 is the covid_gex[[1]]$sample_id==1 and patient2 is the covid_gex[[1]]$sample_id==2.

class(covid_gex) ## list
length(covid_gex) ### list of length one
class(covid_gex[[1]]) ## Seurat object containing GEX from both samples 

```

We can extract which cells come from which sample based on the sample_id in the Seurat object.
```{r}
print(table(covid_gex[[1]]$sample_id)) 
```
We can see that the first patient had 6871 cells and the second patient had 6055 cells found in their gene expression data based on the current filtering. 

Now we can visualize the samples using a UMAP/tsne plot.
```{r, fig.show='hold'}
Seurat::DimPlot(covid_gex[[1]],reduction = "umap")

```
We observe that under this Seurat pipeline there are 12 distinct clusters. The number of clusters can be changed by altering the cluster.resolution argument in the automate_GEX function. 

In this current UMAP we do not see which cells are coming from which patient. To see this, we can simply separate the cells in the DimPlot by the sample_id vector in the Seurat object.
```{r, fig.show='hold'}
Seurat::DimPlot(covid_gex[[1]],reduction = "umap",split.by = "sample_id") 

Seurat::DimPlot(covid_gex[[1]],reduction = "umap")
```


We can observe that the majority of clusters have cells from both patients, suggesting a similar distribution of transcriptional properties between the two samples. We can also plot the cluster membership for each of the distinct samples (patients) using the GEX_cluster_membership function.


```{r}
Platypus::GEX_cluster_membership(automate_GEX.output = covid_gex[[1]])

```

Finally, we can also look at the B cell, CD4 T cell, and CD8 T cell clusters for each patient.
```{r, fig.show='hold'}
#Seurat::FeaturePlot(covid_gex[[1]],reduction = "umap",features = c("CD4","CD8A","CD19"))
Seurat::FeaturePlot(covid_gex[[1]],reduction = "umap",features = c("CD4"))
```


We can see that both patients seem to have B cells (CD19+), CD4 T cells, and CD8 T cells. Platypus also allows us to assign cell type/state identity to different clusters by using GEX_phenotype. This function takes the Seurat object as input and uses canonical markers to easily match the clustering to known cell types. The user also has the possibility to use a custom list of markers and their associated cell types/states.
```{r, results='hide'}
covid_gex_phenotype <- Platypus::GEX_phenotype(covid_gex[[1]], default = T)

covid_gex[[1]] <- Platypus::GEX_phenotype(covid_gex[[1]], default = F,
                                            cell.state.markers=c("CD8A+;CCL5+;CD44+;IL7R-;CD19-",
                          "CD8A+;CCL5-;CD44+;IL7R+;CD19-"),
                        cell.state.names=c("EffectorCD8",
                        "MemoryCD8"))


```
The resulting Seurat object now contains a "cell.state" column which can be used for annotation in the DimPlot function of the Seurat package.

```{r}
Seurat::DimPlot(covid_gex[[1]],reduction = "umap", group.by = "cell.state") 


```



## 3. Differential Gene Analysis

After scaling, normalizing, and clustering the cells from the GEX libraries we can now investigate which genes are differentially expressed between either clusters or samples. First, we can investigate the genes that define each of the clusters by using the GEX_cluster_genes function that takes the output from the automate_GEX function. Depending on the size of the dataset and the number of cells this function can by quite slow. The output of this function is a list in which each element contains the differentially expressed genes for a given cluster. For example, the first element of the list will correspond to a dataframe describing the genes for cluster0 that we previously observed on the UMAP. This list object will correspond to the length of the number of clusters that were previously calculated, and has the same format as the FindMarkers function from Seurat. The pct.1 will correspond to the percentage of cells expressing the gene in the cluster of interest, and the pct.2 to the percentage of cells in all other clusters. 

```{r, fig.show='hold'}
## Warning: running this function will take a while
gene_expression_cluster <- Platypus::GEX_cluster_genes(covid_gex[[1]],min.pct = 0.25) 

length(gene_expression_cluster) ## length of 12, corresponding to 12 clusters
length(unique(covid_gex[[1]]$seurat_clusters)) ## length of 12 
```

We can now look at some of the genes associated with cluster0 in the previously displayed umap
```{r}

head(gene_expression_cluster[[1]])

```
We can see that genes ANXA1, S100A4 or LMNA are highly expressed in this cluster. We can also quantify the total number of differentially expressed genes for all 12 clusters

```{r}
print(sapply(gene_expression_cluster,nrow))
```


It is also possible using Platypus to create a heatmap displaying the differentially expressed genes for each cluster. This can be customized to sub-sample cells in case certain clusters are too large for visualization purposes. Additionally, the user can determine the number of genes to display for each cluster based on the n.genes.per.cluster argument. The function GEX_cluster_genes_heatmap can be used to produce a ggplot object, based on the DoHeatmap from Seurat. 

```{r, fig.show='hold'}

covid_heatmap_clusters <- GEX_cluster_genes_heatmap(automate_GEX.output = covid_gex[[1]],
                                                              GEX_cluster_genes.output = gene_expression_cluster,
                                                              n.genes.per.cluster = 3,max.cell = 30,
                                                              metric = "top_logFC")

print(covid_heatmap_clusters)
```

After plotting the ggplot object we can clearly see genes enriched in various clusters - mainly indicated by the diagonal. 


Earlier we said how we can match the unbiased clustering to known cell types using canonical markers. Platypus also allows us to run a GO or KEGG term analysis in order to obtain information on the most significant GO/KEGG terms and their visualizations using the GEX_GOterm function. (To do this, we first need to organize the top genes that define each Seurat cluster and convert them into a single dataframe. This is done using the GEX_topN_DE_genes_per_cluster function). This function has been commented out because it requires internet connection. 

```{r,results='hide'}

ontology_covid <- Platypus::GEX_GOterm(GEX.cluster.genes.output = gene_expression_cluster, topNgenes = 10, go.plots = F)
head(ontology_covid[[1]])
```

We can additionally extract the top N genes per cluster directly (with filtering) using the following function:

```{r}
#top_10_genes_per_cluster <- Platypus::GEX_topN_DE_genes_per_cluster(GEX_cluster_genes.output = gene_expression_cluster, n.genes = 10, by_FC = T)
#head(top_10_genes_per_cluster)

```

We can also perform a Gene Set Enrichment Analysis (GSEA) using the GEX_GSEA function. For this, the user needs to provide the path to a gmt file containing the gene sets, which can be downloaded for example from MSigDB. For instance we can perform GSEA for cluster0 and look at the most significant pathways.

```{r}
#gsea_covid <- Platypus::GEX_GSEA(GEX.cluster.genes.output = gene_expression_cluster, MT.Rb.filter = T, path_to_pathways = "~/Downloads/c7.all.v7.2.symbols.gmt")
```


We can extract and test for differentially expressed genes between the two samples (or between other subgroups) by using the GEX_DEgenes_persample function. 

This function allows us to also create a heatmap displaying the top most up- or downregulated genes for each cluster based on log fold change (avg_logFC) or p value (adj_p_value). Additionally, the user can determine the number of up- and downreulated genes to be displayed for each sample. In this case, the output returns a list where the first element contains the dataframe with the differntial expression information and the second element contains the heatmap displaying the most up-/downregulated genes.  

```{r, fig.show='hold'}
DE_genes_per_sample <- Platypus::GEX_DEgenes_persample(automate.GEX=covid_gex[[1]],min.pct = .25,sample1 = "1",sample2 = "2",return.plot = TRUE,up.genes = 10,down.genes = 10,logFC = F)

head(DE_genes_per_sample) 
nrow(DE_genes_per_sample[[1]]) ##71 rows 

```




## 3. VDJ Repertoire anaylsis 

### 3.1 Reading in the clonotype data


Now we can analyze the VDJ repertoire data before integrating GEX libraries. This may be useful if only VDJ libraries have been sequenced without the accompanying gene expression data. We first start by reading in the clonotypes based on the default 10x cellranger clonotyping strategy and augmenting the amount of clonal information in the dataframe containing the clonotype information. The first step is to use the VDJ_analyze function on the directory of the outputs from cellranger vdj. The larger BAM files can be removed to save space as the current pipeline does not require these files. 

```{r, fig.show='hold'}
#Read in the directories
VDJ.out.directory.list <- list()
VDJ.out.directory.list[[1]] <- "~/Downloads/PlatypusTestData/Patient1_BCR/"
VDJ.out.directory.list[[2]] <- "~/Downloads/PlatypusTestData/Patient2_BCR/"

#Run VDJ_analyze
covid_vdj_repertoire_bcells <- Platypus::VDJ_analyze(VDJ.out.directory =VDJ.out.directory.list, filter.1HC.1LC = T) 



length(covid_vdj_repertoire_bcells) ## list of length two, first element corresponds to the clones from the first repertoire directory that was set as input. 


VDJ.out.directory.list_TCR <- list()
VDJ.out.directory.list_TCR[[1]] <- "~/Downloads/PlatypusTestData/Patient1_TCR/"
VDJ.out.directory.list_TCR[[2]] <- "~/Downloads/PlatypusTestData/Patient2_TCR/"

#Run VDJ_analyze
covid_vdj_repertoire_tcells <- Platypus::VDJ_analyze(VDJ.out.directory =VDJ.out.directory.list_TCR, filter.1HC.1LC = T) 
```

The output from VDJ_analyze contains various information, including which barcodes make up the clonal family, the nt_clone_ids in case the clonotyping method is changed using the VDJ_clonotype function. Furthermore, the majority germline gene per clonal family is extracted from the contigs file. 

```{r}
print(colnames(covid_vdj_repertoire_bcells[[1]]))
```


### 3.2 Changing the clonotype strategy


Often paired nucleotide CDRH3 and CDRL3 clonotyping may not be the best strategy given somatic hypermutation may occur in the CDR3 region. Therefore, there could be highly similar clones that likely bind the same antigen that are officially part of different clonal families. To address this, we have added a function that allows for various heuristic clonotyping strategies. This involves clonotyping by identical amino acid CDRH3 + CDRL3 seuqence, identical germline usage, or seqeunce homology requirements. This will then update the original clonotyping object from VDJ_analyze by updating the clonotype_id column with the new amino acid acid (or other strategy) used for clonotyping. Similarly, the new clonal family determinant can be found in the new_unique_clone. In the case below, the new_unique_clone will contain the amino acid sequence of  heavy chain and light chain pasted together. If multiple nucleotide clones are merged by changing the clonotyping strategy, their barcodes can be found in the "barcodes" column.  

In the example that follows, we use VDJ_clonotype to group cells into clones based on identical CDRH3 + CDRL3 amino acid sequence. We will compare this to the case in which we group B cells by using the same germline genes (both heavy chain and light chain).

```{r, fig.show='hold'}

covid_vdj_aminoacid_clonotype <- Platypus::VDJ_clonotype(clonotype.list=covid_vdj_repertoire_bcells,
                                                         clone.strategy = "cdr3.aa")

covid_vdj_germline_clonotype <- Platypus::VDJ_clonotype(clonotype.list=covid_vdj_repertoire_bcells,
                                                         clone.strategy = "hvj.lvj")

length(covid_vdj_aminoacid_clonotype) # length of 2
print(colnames(covid_vdj_aminoacid_clonotype[[1]])) 

nrow(covid_vdj_aminoacid_clonotype[[1]]) # 2296 unique clones in patient 1 when clonotyping by amino acid sequence

nrow(covid_vdj_germline_clonotype[[1]]) # 1956 unique clones in patient 1 when clonotyping by germline gene identity

```
We can see that the clonotype_id column now contains the new ids based on this clonotyping strategy. We can always recover the nucleotide ids by looking at the nt_clones_ids.


### 3.3 Getting clonal information at the level of the single cell

So far the functions have been at the clonal level, thereby ignoring cell-specific features that may vary across a clonal family, such as isotypes, sequence variants, etc. The VDJ_per_clone function will provide this information by returning a nested list in which the outer list element corresponds to the repertoire (e.g., list[[1]] is the first directory given as input to the VDJ_analyze function). The inner list element corresponds to a dataframe for each clone. Within this dataframe it is possible to extract information such as the germline gene usage for heavy and light chains (e.g., HC_Vgene is the V gene of the IGH for antibodies or the V gene of the TRB for T cells). Furthermore, one can extract the full sequence of the heavy and light chain for each cell barcode based on the output from cellranger. One issue is that the sequence returned from the fasta files from cellranger extend beyond the FR1 to FR4 region (e.g. constant region, signal peptide), which may be problematic for downstream experimental validation/expression. The same occurs for the germline sequence - again as determined by cellranger. The germline information can be found in the full_HC_germline and full_LC_germline columns in the inner list elements. To obtain the B/TCR sequence that is clonable, one can either proceed with the call_MIXCR function or export the sequences and use a different alignment tool. 


```{r, fig.show='hold'}
covid_single_cell <- Platypus::VDJ_per_clone(clonotype.list = covid_vdj_repertoire_bcells,VDJ.out.directory =VDJ.out.directory.list)


print(paste("There are",length(covid_single_cell[[1]]),"unique nucleotide B cell clones in patient1"),sep="")
print(paste("There are",nrow(covid_single_cell[[1]][[1]]),"unique B cells in the most abundant clone in patient1"),sep="")
print(paste("There are",nrow(covid_single_cell[[2]][[1]]),"unique B cells in the most abundant clone in patient2"),sep="")

print(colnames(covid_single_cell[[1]][[1]]))

covid_single_clone_tcells <- Platypus::VDJ_per_clone(clonotype.list = covid_vdj_repertoire_tcells,VDJ.out.directory =VDJ.out.directory.list_TCR)

```



### 3.4 Extracting full-length sequences from the VDJRegion

To quantify the number of somatic variants or to extract full-length sequences for expression, it is often useful to have the nucleotide sequence from framework region 1 (FR1) to framework region 4 (FR4). Using the call_MIXCR function, the full-length VDJRegion sequences can be added to the clonal information and easily extracted thereafter. This function works on UNIX/Mac and furthermore requires that mixcr is already downloaded locally (with license agreement). One just needs to supply the directory to the executable in the call_MIXCR function as below. Either "mmu" or "hsa" for mouse and human, respectively. Again, the format is similar to the input, in that the outer list corresponds to the individual repertoire and the inner list is a dataframe with various information, including the full-length VDJ sequences (e.g., VDJ.AA.LC and VDJ.AA.HC for the light and heavy chain amino acid sequence). One will notice that the germline sequence is still very long (e.g., in the example below the "full_HC_germline" length is over 600 nucleotides). This will be filled in using the separate function VDJ_extract_germline. 

```{r, fig.show='hold',message=FALSE}

### WARNING: You will need to download MiXCR and change the mixcr.directory to the location of MiXCR
covid_vdj_region <- Platypus::call_MIXCR(VDJ.per.clone = covid_single_cell,mixcr.directory = "~/Downloads/mixcr-3.0.12/mixcr",species = "hsa")

print(length(covid_vdj_region[[1]]))
print(colnames(covid_vdj_region[[1]][[1]]))

print(nchar(covid_vdj_region[[1]][[1]]$VDJ.AA.HC[2])) 

print(nchar(covid_vdj_region[[1]][[1]]$full_HC_germline[1]))

```


### 3.5 Extracting full-length germline sequence corresponding to the VDJRegion

Extracting the germline column can be accomplished using the VDJ_extract_germline, which takes the germline sequence as determined by cellranger. The output contains all the germline sequences in dataframe format for a given repertoire. The original clonotype identifier can be found in the descrR1 column, as seen below. 

```{r, fig.show='hold'}

extracted_covid_germline <- Platypus::VDJ_extract_germline(VDJ.per.clone=covid_single_cell,mixcr.directory="~/Downloads/mixcr-3.0.12/mixcr",extract.VDJRegion=T,species = "hsa")

print(colnames(extracted_covid_germline[[1]][[1]])) ## column names of the germlines from the repertoire corresponding to patient1. 
print(nrow(extracted_covid_germline[[1]][[1]])) ## germline sequences corresponding to 2298 clones in the first patient 
print(nrow(extracted_covid_germline[[2]][[1]])) ## germline sequences corresponding to 2298 clones in the second patient. 


print(extracted_covid_germline[[1]][[1]]$aaSeqCDR3[1]) ## CAREL_FDYW - we can observe unproductive CDR3s for the germline sequence of the first clonotype 



print((extracted_covid_germline[[1]][[1]]$descrsR1[2]))  ## second row in the dataframe corresponds to clonotype4.
print(nchar(extracted_covid_germline[[1]][[1]]$VDJ.AA.HC.LC[2])) ### pasted HC and LC together
print(nchar(extracted_covid_germline[[1]][[1]]$VDJ.AA.HC[2])) ### just heavy chain for clonotype4 germline
print(nchar(extracted_covid_germline[[1]][[1]]$VDJ.AA.LC[2])) ### just light chain for clonotype4 germline



```


### 3.6 Extracting trimmmed VDJ region sequence and germline

The function VDJ_per_clone additionally supplies trimmed VDJ sequences and the corresponding trimmed germline sequences in the case that the all_contig_annotations.json file is available. This can be useful to compute the somatic hypermutation rate only on the VDJ region for single cells in the clonotype. The columns named "full_seq_", "sequence_", and "trimmed_ref_" represent the sequence returned from the fasta files from cellranger, the sequence trimmed at the VDJ region, and the germline sequence trimmed at the VDJ region (followed by HC for Heavy Chain and LC for Light Chain). This data does not require MiXCR alignment, however, it is not necessarily starting at Framework1 so please use with caution if future plans involve cloning BCR/TCR. We have commented this out as the test data did not include the JSON file at the time. 

```{r, fig.show='hold'}

#covid_single_clone_with_JSON <- VDJ_per_cell(clonotype.list = covid_vdj_repertoire_bcells,VDJ.out.directory =VDJ.out.directory.list,JSON = T)


# covid_single_cell was the object from VDJ_per_clone

#print(covid_single_clone_with_JSON[[1]][[1]]$trimmed_HC_sequence[1])  # trimmmed sequence 
#print(covid_single_clone_with_JSON[[1]][[1]]$trimmed_HC_germline[1])  # trimmmed germline sequence 

#stringdist::stringdist(covid_single_clone_with_JSON[[1]][[1]]$sequence_HC[1], VDJ.per.cell[[1]][[1]]$trimmed_ref_HC[1]) 
```


### 3.7 Organizing full-length sequences into clonal lineages easily exportable for phylogenetics. 

After extracting the germline sequences and the full-length VDJRegion sequences, we can combine this information and group the sequences into clonal lineages that can individually be exported for downstream phylogenetics or into the VDJ_tree function within Platypus. The output list is similar to the output of other VDJ functions, in which the outer list element corresponds to the repertoire and the inner list element corresponds to the individual clone/clonal families. Here the heavy chain and light chain have been pasted together but in case one wants to separate them, the information can be found in the output of the VDJ_extract_germline function. For example, the output of the VDJ_extract_germline function above was extracted_covid_germline[[1]][[1]]$VDJ.AA.HC.LC[2]. In this sequence there is a "_" at the end of the heavy chain and light chain sequences. So one can split the strings at "_" and use this sequence to create the phylogenetic trees. 


```{r, fig.show='hold'}


covid_clonal_lineages <- Platypus::VDJ_clonal_lineages(call_MIXCR.output=covid_vdj_region, VDJ_extract_germline.output=extracted_covid_germline,as.nucleotide=F,with.germline=T)

print(colnames(covid_clonal_lineages[[1]][[1]])) ## dataframe with the columns Seq and Name. 

print(covid_clonal_lineages[[1]][[1]]$Seq[1])

print(covid_clonal_lineages[[1]][[1]]$Name[1]) #"clonotype3_1_IGHA1_AACCATGAGTGGAGTC-1"
## Here we can see that the above sequence corresponds to the original clonotype3 but is now the first clonal lineage (as seen by the _1_ before the isotype). Furthermore, the isotype of this cell was of the IGHA1. Lastly, we have the barcode of the cell at the end, allowing us to look back at other cell-specific properties if wanted. 


print(covid_clonal_lineages[[1]][[3]]$Name[3]) #"clonotype7_3_IGHA1_AGTGAGGTCGAGAACG-1"
## Again, this was originally the 7th clonotype, and is now the third most clonally expanded lineage ("_3_") of the IGHA1 isotype with given barcode. 

print(tail(covid_clonal_lineages[[1]][[3]]$Name))  ## here at the end of the dataframe the user can also see the germline sequence, which has the "Name" of "germline". 



```

### 3.8 Neighbor-joining phylogenetic trees

The output of the VDJ_clonal_lineage function can be used as input to the VDJ_tree to produce quick, neighbor-joining phylogenetic trees. It is important that the VDJRegion is considered (or that the sequences from 10x have been trimmed) as this function does not involve a multiple string alignment - instead it creates a distance matrix from all sequences. The min number of unique sequences can be specified (e.g., if there are 50 cells in a clonal lineage, but only one unique antibody sequence, this tree will not be produced). Similarly, the max number of sequences can be specified, which will then result in random sampling from all sequences. Plotting the first tree we can see the that there is one variant (named Seq_1) that has 90 cells (seen by the Freq_90) and it is very close to the germline (Seq_6_Freq_1). We know it is the germline because it is the highest sequence variant and it is set as the root. 

```{r, fig.show='hold'}


covid_trees <- Platypus::VDJ_tree(clonal.lineages = covid_clonal_lineages,with.germline=T,min.sequences = 5,max.sequences = 30,unique.sequences = T)
plot(covid_trees[[1]][[1]])


```


### 3.9 Plotting per-cell isotype information 

Additional VDJ functions include plotting the isotype distribution per clone. This can be performed by the VDJ_isotypes_per_clone function and setting the number of clones to show. The following code extracts and plots the isotype distribution of the top 30 clones. We can see a clear IgA isotype majority of the top four clones in the first patient when using the default clonotyping strategy. We can additionally use the new clonotyping strategies to compare how changing the clonal defintion impacts the clonal expansion profiles. We simply supply the output from VDJ_clonotype  

```{r, fig.show='hold'}

covid_isotypes <- Platypus::VDJ_isotypes_per_clone(VDJ_clonotype_output = covid_vdj_repertoire_bcells, VDJ_per_clone_output = covid_single_cell, clones = 30)

covid_isotypes_aa_clonotype <- Platypus::VDJ_isotypes_per_clone(VDJ_clonotype_output = covid_vdj_germline_clonotype, VDJ_per_clone_output = covid_single_cell, clones = 30)

covid_isotypes_germline_clonotype <- Platypus::VDJ_isotypes_per_clone(VDJ_clonotype_output = covid_vdj_aminoacid_clonotype, VDJ_per_clone_output = covid_single_cell, clones = 30)

print(covid_isotypes[[1]])


```

In the second patient (second repertoire entered in original VDJ_analyze) we also see a similarly expanded IgA clone with over 60 cell barcodes. 

```{r, fig.show='hold'}
print(covid_isotypes[[2]])
```

### 3.10 Sequence similarity networks

Other functions are specifically tailored to repertoire analysis - such as VDJ_network, which creates a sequence similarity network between repertoires or within a repertoire by connecting those clones with sequence similarity. This function relies upon igraph to visually display and construct the graph - which means that networks with high number of sequences will not display easily. In the following example we take the top 60 most expanded clones from the output of VDJ_analyze and use this as input into the network construction function. Setting the per.mouse argument to false indicates that one network for multiple repertoires should be produced.  

```{r, fig.show='hold'}
## Take the output from VDJ_analyze (or subsample as in this case the top 60 clones)
network_clones_covid <- list()
network_clones_covid[[1]] <- covid_vdj_repertoire_bcells[[1]][1:60,]
network_clones_covid[[2]] <- covid_vdj_repertoire_bcells[[2]][1:60,]
network_clones_covid <- list()
network_clones_covid[[1]] <- covid_vdj_repertoire_tcells[[1]][1:60,]
network_clones_covid[[2]] <- covid_vdj_repertoire_tcells[[2]][1:60,]

covid_bcell_igraph <- Platypus::VDJ_network(network_clones_covid[1:2],per.sample = F,distance.cutoff = 10,connected = F)
covid_bcell_igraph_d14 <- Platypus::VDJ_network(network_clones_covid[1:2],per.sample = F,distance.cutoff = 14,connected = F)


igraph::plot.igraph(covid_bcell_igraph[[4]],vertex.label=NA,vertex.size=7+(.06*covid_bcell_igraph[[2]]$frequency),vertex.color=factor(covid_bcell_igraph[[2]]$mouse))
igraph::plot.igraph(covid_bcell_igraph_d14[[4]],vertex.label=NA,vertex.size=7+(.06*covid_bcell_igraph_d14[[2]]$frequency),vertex.color=factor(covid_bcell_igraph_d14[[2]]$mouse))



```

For more details see the documentation of the VDJ_network function, but essentially information such as clonal frequency and which sample (here still indicated by the "mouse" column) are stored in the second element of the output list. Here we can see only a few clones that are showing connections (produced by edges between those with a distance of 8 amino acids or less between heavy and light chain paired CDR3 sequence homology)


### 3.11 Germline gene usage heatmaps 

It is also possible to produce heatmaps of the germline gene usage in the context of heavy chain V gene and light chain V gene. The output of the VDJ_Vgene_usage function is a matrix for each repertoire corresponding to the order specified by VDJ_analyze. The outer list corresponds to the sample and the inner list corresponds to a matrix, where the rows correspond to the heavy chain V genes and the columns correspond to the light chains of the V genes. Therefore the output[[1]][i,j] corresponds to the number of clones using the combination of IGH-Vgene[i] and IGK/L-Vgene[j]. 

```{r, fig.show='hold'}

#First calculate adjacency matrix for V gene usage
covid_Vgene_usage <- Platypus::VDJ_Vgene_usage(VDJ.clonotype.output = covid_vdj_repertoire_bcells)
library(pheatmap)

pheatmap::pheatmap(covid_Vgene_usage[[1]],show_rownames = F,show_colnames = F)


print(class(covid_Vgene_usage[[1]]))
print(head(rownames(covid_Vgene_usage[[1]])))
print(head(colnames(covid_Vgene_usage[[1]])))
```
This can then be easily plotted as a heatmap to observe patterns between repertoires or can be used to calculate V gene correlation using the "pheatmap" package. 

Platypus also allows a separate analysis of V gene usage for HC and LC. The VDJ_Vgene_usage_barplot allows the user to plot most frequently used IgH or IgK/L V genes. By default, this function only provides visualizations for the HC V genes, but can also provide for the LC if LC. Vgene is set to TRUE. The User can also select the number of most used genes to be depicted.
```{r}
covid_Vgene_usage_barplot <- Platypus::VDJ_Vgene_usage_barplot(covid_vdj_repertoire_bcells, HC.gene.number = 10, LC.Vgene = T, LC.gene.number = 10)
print(covid_Vgene_usage_barplot[[1]])


example.vdj.vgene_usage <- Platypus::VDJ_Vgene_usage_stacked_barplot(clonotype.list = covid_vdj_repertoire_bcells, LC.Vgene = F,HC.gene.number = 10, Fraction.HC = 1)
example.vdj.vgene_usage[[1]]

```

Furthermore, we can also produce a circular visualization of how V and J genes are combined throughout the repertoire. In the example that follows we use VDJ_VJ_usage_circos to look at the V gene with the corresponding J gene for each expanded clonotype. 

```{r}

vj_circos_bcells <- Platypus::VDJ_VJ_usage_circos(covid_vdj_repertoire_bcells[2:2], c.threshold = 1,label.threshold=50,cell.level = T)

vj_circos_tcells <- Platypus::VDJ_VJ_usage_circos(covid_vdj_repertoire_tcells[1:1], c.threshold = 1,label.threshold=50,cell.level = T)



```



### 3.12 Assessing CDR3 sequence similarity

Finally, one can also look at any specific HC and LC CDR3 amino acid patterns arising across the different clones. Using the VDJ_logoplot function the user can plot a logoplot of the CDR3 region od a certain length, specyfied by the length_cdr3 argument. For instance, the logoplot below corresponds to all those CDR3 aminoacid sequences of length 25

```{r}
covid_CDR3_logoplot <- Platypus::VDJ_logoplot(VDJ.object = covid_vdj_repertoire_bcells, length_cdr3 = 25)
```


## 4. Integrating repertoire and gene expression
 
The strength of the current 5' sequencing protocols are that the gene expression (GEX) and repertoire (VDJ) libraries are extracted from the same sample, which can then be linked back to demonstrate that a given T cell has a certain gene expression pattern and also a certain T cell receptor sequence. The following functions are meant to integrate these two pieces of information.

### 4.1 Integrating transcriptional clusters to the VDJ objects

One thing we may ask is how similar the B or T cells in a given clonal family are on the transcriptional level. One way we can do this, is to take advantage of the transcriptional clustering performed in the automate_GEX function and then supply this information to the repertoire information. This can either be done on the level of the clone (e.g., in the format of the output of VDJ_analyze) or on the level of the cell (e.g., in the format of the output of VDJ_per_clone). Below is the example of the clonal level. The output is the same as the VDJ_analyze output, except now there are columns corresponding to the majority transcriptome cluster (e.g., if the majority of cells within the clone are in cluster 1, then this column will have a 1). Next to this there is a column that tells you the cluster percentage for all cells in that clone. Finally, there is the cell index in the GEX object so you can see which cells are found in the GEX object and can explicitly call them. 

```{r, fig.show='hold'}

covid_integrating_clonal_level <- Platypus::VDJ_GEX_integrate(GEX.object = covid_gex[[1]], 
                                                 clonotype.list =  covid_vdj_repertoire_bcells,
                                                 VDJ.per.clone = covid_single_cell,
                                                 clonotype.level = TRUE)
covid_integrating_clonal_level_tcell <- Platypus::VDJ_GEX_integrate(GEX.object = covid_gex[[1]], 
                                                 clonotype.list =  covid_vdj_repertoire_tcells,
                                                 VDJ.per.clone = covid_single_cell,
                                                 clonotype.level = TRUE)

print(head(covid_integrating_clonal_level[[1]]$majority_cluster))
print(head(covid_integrating_clonal_level[[1]]$cluster_membership_percent))
print(head(covid_integrating_clonal_level[[1]]$cell_index))
```


On the cell level - the output has a similar structure to the VDJ_per_clone function output. Again, we can print out the cluster membership and the cell indices for the 5th clone from the first patient's repertoire. If the cell is only found in the VDJ repertoire and not in the GEX repertoire, it will be a blank element. As seen by the 6th cell in this clonal family.


```{r, fig.show='hold'}

covid_integrating_cell_level <- Platypus::VDJ_GEX_integrate(GEX.object = covid_gex[[1]], 
                                                 clonotype.list =  covid_vdj_repertoire_bcells[1:1],
                                                 VDJ.per.clone = covid_single_cell[1:1],
                                                 clonotype.level = FALSE)


print(head(covid_integrating_cell_level[[1]][[5]]$cluster_membership))
print(head(covid_integrating_cell_level[[1]][[5]]$cell_index))
```


### 4.2 Relating clonal expansion to transcriptional cluster membership

The VDJ_GEX_expansion function takes the previously integrated VDJ and GEX datasets and then plots the distribution of transcriptional cluster membership for the specified clones. In the following example, we plot the the top 20 clones and their distribution of cluster membership. 

```{r, fig.show='hold'}

covid_clonotype_clusters_plot <-  Platypus::VDJ_GEX_expansion(GEX.list=covid_gex[[1]],
                                                              VDJ.GEX.integrate.list = covid_integrating_clonal_level,
                                                              highlight.isotype = "None",
                                                              highlight.number=1:10)


covid_clonotype_clusters_plot_tcells <-  Platypus::VDJ_GEX_expansion(GEX.list=covid_gex[[1]],
                                                              VDJ.GEX.integrate.list = covid_integrating_clonal_level_tcell,
                                                              highlight.isotype = "None",
                                                              highlight.number=1:10)

print(covid_clonotype_clusters_plot_tcells[[2]])



```

We see that some clones did not have any barcodes overlapping between the GEX and VDJ data sets for this particular patient and therefore there is no bar at that given clonal index on the X axis. 


### 4.3 Visualizing clones on the 2 dimensional landscape

In the case we want to overlay clones on the tSNE/UMAP space that we previously calculated using automate_GEX, this can be accomplished with the visualize_clones_GEX function. The following code will overlay the top 10 clones on the UMAP space calculated with the automate_GEX function. The group correspond to the clonal order - e.g., group 1 is the first clonal family in the integrated VDJ list. Here we can see that there are a few cells in the T cell cluster, suggesting that there were duplets during cell capture since in this experiment B and T cells were pooled in a single reaction. 

```{r, fig.show='hold'}

covid_top10_umap <- Platypus::GEX_visualize_clones(GEX.list=covid_gex,
                     VDJ.GEX.integrate.list=covid_integrating_clonal_level_tcell[2:2],
                     highlight.type="clonotype",
                     highlight.number=1:10,
                     reduction="umap")
print(covid_top10_umap[[1]]) 

```



### 4.4 Specific gene expression information on the clonal level

We previously integrated the GEX information into the format of the VDJ output. However, we may want to ask how the gene expression looks for certain clonotypes (e.g., how many of the cells in the top clone are expressing Fas/GL7 or germinal center cell markers). Therefore, we need to integrate the VDJ information and barcodes into the GEX object. This can be done by using the clonotype_GEX function followed by the GEX_heatmap function. To save space, the output of this function can be assigned to the original automate_GEX output, as it will be another Seurat object. By setting b.or.t to "b", a panel of pre-selected B cell genes will be displayed. One can also supply custom genes to test specific clonotypes. The group/column colors correspond to given clonal families. 

```{r, fig.height=20}

covid_gex_integrate <- Platypus::GEX_clonotype(GEX.object=covid_gex[[1]],VDJ.per.clone = covid_single_clone_tcells)

covid_gex_integrate_bcells <- Platypus::GEX_clonotype(GEX.object=covid_gex[[1]],VDJ.per.clone = covid_single_cell)


GEX_phenotype_per_clone_plot <- Platypus::GEX_phenotype_per_clone(seurat.object = covid_gex_integrate, clonotype.ids= c(1,2,3,4,5))

print(GEX_phenotype_per_clone_plot)

covid_tcell_gene_heatmap <- Platypus::GEX_heatmap(covid_gex_integrate,b.or.t = "t",clone.rank.threshold = 20,sample.index = 1)


covid_bcell_gene_heatmap <- Platypus::GEX_heatmap(covid_gex_integrate_bcells,b.or.t = "b",clone.rank.threshold = 20,sample.index = 1)



```


### 4.5 Integrating clonal lineage information and transcriptional cluster information

We can supply transcriptional cluster information into the clonal lineages organized earlier. This can be done using the VDJ_GEX_clonal_lineage_clusters function, which will place the transcriptional cluster information into the Name of the clonal_lineage object. Since we only integrated the first patient in the covid_integrating_cell_level object, we will just take the first patients clonal lineages. Now if we print the name of the first sequence in the first clonal lineage, we see that a cluster5 has been added to the end of the name. This indicates that this particular B cell was found in cluster5 from the original automate_GEX. 


```{r, fig.show='hold'}

clonal_lineage_integrate <- Platypus::VDJ_GEX_clonal_lineage_clusters(covid_integrating_cell_level,covid_clonal_lineages[1:1])

print(clonal_lineage_integrate[[1]][[1]]$Name[1])



```

### 5 Version information

```{r, fig.show='hold'}

sessionInfo()


```


