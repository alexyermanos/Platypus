---
title: "Platypus vignette"
author: "Alexander Yermanos"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Platypus vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Introduction

Platypus is a package designed to facilitate the data analysis of single-cell immune repertoire sequencing experiments. The package can be used to separately analyze gene expression (GEX) or immune receptor repertoire (VDJ) sequencing data, in addition to integrating the two data sets to combine phenotypic features with repertoire analysis. The package is designed to primarily analyze the output from 10x genomics cellranger (output from count for GEX and vdj for enriched immune receptor libraries). The functions could work with other barcode-based scSeq technologies assume the input columns are added correctly. The gene expression analysis relies heavily upon Seurat, a commonly used R package for single-cell sequencing (scSeq). 


## 2. Gene expression analysis

The output from cellranger's count function returns gene expression information in the form of an expression matrix, barcodes, and gene identifiers. The input directory should be set to the directory containing these three files (barcodes.tsv.gz, features.tsv.gz, matrix.mtx.gz). If it is desired to analyze multiple distinct transcriptomes (e.g. on separate UMAP space), these directories should go into separate list objects. For example if there are 20 repertoires and it is wanted to analyze them separately (20 separate UMAPs, 20 separate repertoires) then each outer list element of the input directories will contain the directory for the individual repertoire/GEX files. In the example below in which two directories are supplied to a single list element, these two distinct transcriptomes (corresponding to two distinct repertoires) will be merged together.

The output of this function is a Seurat object similar to the standard pipeline demonstrated in the Seurat vignette. This involves scaling, normalizing, clustering, and performing dimension reductionality (tSNE and UMAP by default). At this stage there is no incorporation of repertoire features, which need to be explicitly integrated using subsequent functions in Platypus. 
 

```{r, fig.show='hold'}

### loading the package
#source("~/Downloads/Platypus-master/Platypus_1.1.tar.gz")
library(Platypus)

dir_to_covid_gex_individual <- list()
dir_to_covid_gex_individual[[1]] <- c("~/Downloads/covid_data/Patient1_GEX/")
dir_to_covid_gex_individual[[2]] <- c("~/Downloads/covid_data/Patient2_GEX/") ## adding the single directory 



# Now we run automate_GEX to perform the standard Seurat pipeline in a single line of code with the ability to change the parameters used by Seurat involving minimum read numbers, mitochondrial gene percentages, cluster resolution, etc. This example will result with a single Seurat GEX object. 


covid_gex_individual <- Platypus::automate_GEX(GEX.outs.directory.list = dir_to_covid_gex_individual,integration.method = "scale.data",mito.filter = 20,cluster.resolution = 0.5,VDJ.gene.filter = T)
#VDJ.gene.filter removes antibody and TCR genes from the data set (e.g. IGHV1-1) to not let clonality impact transcriptional clustering. 
length(covid_gex_individual) ## length of two 
class(covid_gex_individual) ## list class
class(covid_gex_individual[[1]]) ## Seurat object 
ncol(covid_gex_individual[[1]]) ## 6055 cells
ncol(covid_gex_individual[[2]]) ## 6871 cells

## Now can visualize the individual samples using UMAP/tsne plots 
Seurat::DimPlot(covid_gex_individual[[1]],reduction = "umap")


```

```{r, fig.show='hold'}


Seurat::FeaturePlot(covid_gex_individual[[1]],reduction = "umap",features = c("CD4","CD8A","CD19"))
## Here we can see the B, CD4 and CD8 clusters within the individual patient.


### Integrating two GEX libraries into one Seurat object
dir_to_covid_gex <- list()
dir_to_covid_gex[[1]] <- c("~/PHD/covid_patients/GEX/Both_flowcell_alignments/5921925/filtered_feature_bc_matrix/",
                           "~/PHD/covid_patients/GEX/Both_flowcell_alignments/5922423/filtered_feature_bc_matrix/")

covid_gex <- Platypus::automate_GEX(GEX.outs.directory.list = dir_to_covid_gex[1:1],integration.method = "scale.data",mito.filter = 20,cluster.resolution = 0.5,VDJ.gene.filter = T)


### Now both gene expression samples will be integrated together. The covid_gex[[1]]$sample_id contains the sample origin information based on the order of the input directories. In this case, patient1 is the covid_gex[[1]]$sample_id==1 and patient2 is the covid_gex[[1]]$sample_id==2.

class(covid_gex) ## list
length(covid_gex) ### list of length one
class(covid_gex[[1]]) ## Seurat object

## We can extract which cells come from which sample based on the sample_id in the Seurat object. 
print(table(covid_gex[[1]]$sample_id)) 
## we can see that the first patient had 6871 cells and the second patient had 6055 cells found in their gene expression data based on the current filtering. 

```


```{r, fig.show='hold'}


## Now can visualize the individual samples using UMAP/tsne plots 
Seurat::DimPlot(covid_gex[[1]],reduction = "umap")

### We observe that under this Seurat pipeline there are 12 distinct clusters. The number of clusters can be changed by altering the cluster.resolution argument in the automate_GEX function. In this current UMAP we do not see which cells are coming from which patient. 
```


```{r, fig.show='hold'}

Seurat::DimPlot(covid_gex[[1]],reduction = "umap",split.by = "sample_id") # the resulting DimPlot now has separated the cells by the sample_id vector in the Seurat object. We can visually observe that the majority of clusters have cells from both patients, suggesting a similar distribution of transcriptional properties between the two samples. 

```

```{r, fig.show='hold'}


Seurat::FeaturePlot(covid_gex[[1]],reduction = "umap",features = c("CD4","CD8A","CD19"))
## Again we can see the B, CD4 and CD8 clusters from the cells of both patients. 
```


```{r, fig.show='hold'}

Seurat::FeaturePlot(covid_gex[[1]],reduction = "umap",features = c("CD4","CD8A","CD19"),split.by = "sample_id")
## Again, splitting by sample_id we can look at specific markers for each patient. We can see that both patients seem to have B cells (CD19+) , CD4 T cells, and CD8 T cells. 




```

## 3. Differential Gene Analysis

After scaling, normalizing, and clustering the cells from the GEX libraries we can now investigate which genes are differentially expressed between either clusters or samples. First we can investigate those genes that define each of the clusters by using the GEX_cluster_genes function that takes the output from the automate_GEX function. Depending on the size of the data set and the number of cells this function can by quite slow. The output of this will be a list in which each element contains to the differentially expressed genes for a given cluster. For example the first element of the list corresponds to a dataframe describing the genes for cluster0 that we previously observed on the UMAP. This list object will correspond to the length of the number of clusters and has the same format as the FindMarkers function from Seurat. The pct.1 will correspond to the percentage of cells expressing the gene in the cluster of interest, and the pct.2 corresponds to the rest of the cells in other clusters. 

```{r, fig.show='hold'}
## GEX_cluster_genes will return a list containing the genes differentially up or down regulated for each cluster. 
## Warning: running this function will take a while
gene_expression_cluster <- Platypus::GEX_cluster_genes(covid_gex[[1]],min.pct = 0.25) 

length(gene_expression_cluster) ## length of 12, corresponding to 12 clusters
length(unique(covid_gex[[1]]$seurat_clusters)) ## length of 12 


### This gives the genes associated with cluster0 in the previously displayed umap - also corresponding to the cells found at covid_gex[[1]]$seurat_clusters==0 
head(gene_expression_cluster[[1]])
# We see the genes ANXA1, S100A4 etc are highly expressed in cluster0. 

# Here we can quantify the number of differentially expressed genes for all 12 clusters

print(sapply(gene_expression_cluster,nrow))


```

It is also possible using Platypus to create a heatmap displaying the differentially expressed genes for each cluster. This can be customized to sub-sample cells in case certain clusters are too large for visualization purposes. Additionally, the user can determine the number of genes to display for each cluster based on the n.genes.per.cluster argument. The function GEX_cluster_genes_heatmap can be used to produce a ggplot object, based on the DoHeatmap from Seurat. After plotting the ggplot object we can clearly see genes enricheded in the various clusters - mainly indicated by the diagonal. 


```{r, fig.show='hold'}

covid_heatmap_clusters <- Platypus::GEX_cluster_genes_heatmap(automate_GEX.output = covid_gex[[1]],
                                                              GEX_cluster_genes.output = gene_expression_cluster,
                                                              n.genes.per.cluster = 5,max.cell = 50,
                                                              metric = "avg_logFC")

print(covid_heatmap_clusters)


```




We can also extract and test for differentially expressed genes between the two samples. This can be done using the GEX_DEgenes_persample function. 



```{r, fig.show='hold'}

DE_genes_per_sample <- GEX_DEgenes_persample(automate.GEX=covid_gex[[1]],min.pct = .25,sample1 = "1",sample2 = "2")


head(DE_genes_per_sample) 
nrow(DE_genes_per_sample) ##71 rows 



```




## 3. VDJ Repertoire anaylsis 

### 3.1 Reading in the clonotype data


Now we can analyze the VDJ repertoire data without integrating GEX libraries. This may be useful if only VDJ libraries have been sequenced without the accompanying gene expression data. We first start by reading in the clonotypes based on the default 10x cellranger clonotyping strategy and augmenting the amount of clonal information in the a dataframe containing the clonotype information. The first step is to use the VDJ_analyze function on the directory of the outputs from cellranger vdj. The larger BAM files can be removed to save space as the current pipeline does not require these files. 

```{r, fig.show='hold'}
VDJ.out.directory.list <- list()
VDJ.out.directory.list[[1]] <- "~/Downloads/covid_data/Patient1_VDJ_Bcell_out/"
VDJ.out.directory.list[[2]] <- "~/Downloads/covid_data/Patient2_VDJ_Bcell_out/"

covid_vdj_repertoire_bcells <- Platypus::VDJ_analyze(VDJ.out.directory =VDJ.out.directory.list, filter.1HC.1LC = T) 


length(covid_vdj_repertoire_bcells) ## list of length two, first element corresponds to the clones from the first repertoire directory that was set as input. 
print(colnames(covid_vdj_repertoire_bcells[[1]]))

## Can see various information, including which barcodes make up the clonal family, the nt_clone_ids incase the clonotyping method is changed using the VDJ_clonotype function. Furthermore, the majority germline gene per clonal family is extracted from the contigs file. 

```

### 3.2 Changing the clonotype strategy


Often paired nucleotide CDRH3 and CDRL3 clonotype may not be the best strategy given somatic hypermutation may occur in the CDR3 region. Therefore there could be highly similar clones that likely bind the same antigen that are officially part of different clonal families. To address this we have added a function that allows for various heuristic clonoptying strategies. This involves clonotpying by identical amino acid CDRH3 + CDRL3 seuqence, identical germline usage, or seqeunce homology requirements. This will then update the original clonotyping object from VDJ_analyze by updating the clonotype_id column with the new amino acid acid (or other strategy) used for clonotyping. Similarly, the new clonal family determinant can be found in the new_unique_clone. In the case below, the new_unique_clone will contain the amino acid seqeunce of the heavy chain and light chain pasted together. If multiple nucleotide clones are merged by changing the clonotyping strategy, their barcodes can be found in the barcodse column.  



```{r, fig.show='hold'}

covid_vdj_aminoacid_clonotype <- Platypus::VDJ_clonotype(clonotype.list=covid_vdj_repertoire_bcells,
                                                         clone.strategy="cdr3.aa")

length(covid_vdj_aminoacid_clonotype) # length of 2

print(colnames(covid_vdj_aminoacid_clonotype[[1]])) 

```



### 3.3 Getting clonal information at the level of the single cell

So far the functions have been at the clonal level, thereby ignoring cell-specific features that may vary across a clonal family, such as isotypes, sequence variants, etc. The VDJ_per_clone function will provide this information by returning a nested list in which the outer list element corresponds to the repertoire (e.g. list[[1]] is the first directory given as input to the VDJ_analyze function). The inner list element corresponds to a dataframe for each clone. Within this dataframe it is possible to extract information such as the germline gene usage for heavy and light chains (e.g. HC_Vgene is the V gene of the IGH for antibodies or the V gene of the TRB for T cells). Furthermore, one can extract the full sequence of the heavy and light chain for each cell barcode based on the output from cellranger. One issue with this is that the sequence returned from the fasta files from cellranger extend beyond the FR1 to FR4 region (e.g. constant region, signal peptide), which may be problematic for downstream experimental validation/expression. The same occurs for the germline sequence - again as determined by cellranger. The germline information can be found in the full_HC_germline and full_LC_germline columns in the inner list elements. To obtain the B/TCR sequence that is clonable, one can either proceed with the call_MIXCR function or export the sequences and use a different alignment tool. 


```{r, fig.show='hold'}

covid_single_cell <- Platypus::VDJ_per_clone(clonotype.list = covid_vdj_repertoire_bcells,VDJ.out.directory =VDJ.out.directory.list)

print(paste("There are",length(covid_single_cell[[1]]),"unique nucleotide B cell clones in patient1"),sep="")

print(paste("There are",nrow(covid_single_cell[[1]][[1]]),"unique B cells in the most abundant clone in patient1"),sep="")

print(paste("There are",nrow(covid_single_cell[[2]][[1]]),"unique B cells in the most abundant clone in patient2"),sep="")


print(colnames(covid_single_cell[[1]][[1]]))


```



### 3.4 Extracting full-length sequences from the VDJRegion

To quantify the number of somatic variants or to extract full-length sequences for expression, it is often useful to have the nucleotide sequence from framework region 1 (FR1) to framework region 4 (FR4). Using the call_MIXCR function, the full-length VDJRegion sequences can be added to the clonal information and easily extracted thereafter. This function works on UNIX/mac and furthermore requires that mixcr is already downloaded locally (and license agreement . One just needs to supply the directory to the executable in the call_MIXCR function as below. Either "mmu" or "hsa" for mouse and human, respectively. Again the format is similar to the input, in that the outer list corresponds to the individual repertoire and the inner list is a dataframe with various information, including the full-length VDJ sequences (e.g. VDJ.AA.LC and VDJ.AA.HC for the light and heavy chain amino acid sequence). You will notice that the germline sequence is still very long (e.g. in the example below looking at the "full_HC_germline" length is over 600 nucleotides). this will be filled in using the separate function VDJ_extract_germline. 

```{r, fig.show='hold'}

covid_vdj_region <- Platypus::call_MIXCR(VDJ.per.clone = covid_single_cell,mixcr.directory = "~/Downloads/mixcr-3.0.12/mixcr",species = "hsa")

print(length(covid_vdj_region[[1]]))
print(colnames(covid_vdj_region[[1]][[1]]))

print(nchar(covid_vdj_region[[1]][[1]]$VDJ.AA.HC[2])) 

print(nchar(covid_vdj_region[[1]][[1]]$full_HC_germline[1]))

```


### 3.5 Extracting full-length germline sequence corresponding to the VDJRegion

Extracting the germline column can be accomplished using the VDJ_extract_germline, which takes the germline sequence as determined by cellranger. The output contains all the germline sequences in dataframe format for a given repertoire. The original clonotype identifier can be found in the descrR1 column, as seen below. 

```{r, fig.show='hold'}

extracted_covid_germline <- VDJ_extract_germline(VDJ.per.clone=covid_single_cell,mixcr.directory="~/Downloads/mixcr-3.0.12/mixcr",extract.VDJRegion=T,species = "hsa")

print(colnames(extracted_covid_germline[[1]][[1]])) ## column names of the germlines from the repertoire corresponding to patient1. 
print(nrow(extracted_covid_germline[[1]][[1]])) ## germline sequences corresponding to 2298 clones in the first patient 
print(nrow(extracted_covid_germline[[2]][[1]])) ## germline sequences corresponding to 2298 clones in the second patient. 


print(extracted_covid_germline[[1]][[1]]$aaSeqCDR3[1]) ## CAREL_FDYW - we can observe unproductive CDR3s for the germline sequence of the first clonotype 



print((extracted_covid_germline[[1]][[1]]$descrsR1[2]))  ## second row in the dataframe corresponds to clonotype4.
print(nchar(extracted_covid_germline[[1]][[1]]$VDJ.AA.HC.LC[2])) ### pasted HC and LC together
print(nchar(extracted_covid_germline[[1]][[1]]$VDJ.AA.HC[2])) ### just heavy chain for clonotype4 germline
print(nchar(extracted_covid_germline[[1]][[1]]$VDJ.AA.LC[2])) ### just light chain for clonotype4 germline



```


### 3.6 Extracting trimmmed VDJ region sequence and germline

The function VDJ_per_cell combines the features that are obtained from VDJ_per_clone with trimmed VDJ sequences and the corresponding trimmed germline sequences. This can be useful to compute the somatic hypermutation rate only on the VDJ region for single cells in the clonotype. The columns named "full_seq_", "sequence_", and "trimmed_ref_" represent the sequence returned from the fasta files from cellranger, the sequence trimmed at the VDJ region, and the germline sequence trimmed at the VDJ region (followed by HC for Heavy Chain and LC for Light Chain).

```{r, fig.show='hold'}

VDJ.per.cell <- VDJ_per_cell(clonotype.list = VDJ_analyze.output, VDJ.out.directory = VDJ.out.directory.list)

print(VDJ.per.cell[[1]][[1]]$sequence_HC)  # trimmmed sequence 
print(VDJ.per.cell[[1]][[1]]$trimmed_ref_HC)  # trimmmed sequence 
stringdist::stringdist(VDJ.per.cell[[1]][[1]]$sequence_HC, VDJ.per.cell[[1]][[1]]$trimmed_ref_HC) 
```


### 3.7 Organizing full-length sequences into clonal lineages easily exportable for phylogenetics. 

After extracting the germline sequences and the full-length VDJRegion sequences, we can combine this information and group the sequences into clonal lineages that can individually be exported for downstream phylogenetics or into the VDJ_tree function within Platypus. The output list is similar to the output of other VDJ functions, in which the outer list element corresponds to the repertoire and the inner list element corresponds to the individual clone/clonal families. Here the heavy chain and light chain have been pasted together but in case one wants to separate them, the information can be found in the output of the VDJ_extract_germline function. For example, above the output of the VDJ_extract_germline function was extracted_covid_germline[[1]][[1]]$VDJ.AA.HC.LC[2]. In this sequence there is a "_" at the end of the heavy chain and light chain sequences. So one can split the strings for this and use this sequence to create the phylogenetic trees. 


```{r, fig.show='hold'}


covid_clonal_lineages <- VDJ_clonal_lineages(call_MIXCR.output=covid_vdj_region, VDJ_extract_germline.output=extracted_covid_germline,as.nucleotide=F,with.germline=T)

print(colnames(covid_clonal_lineages[[1]][[1]])) ## dataframe with the columns Seq and Name. 

print(covid_clonal_lineages[[1]][[1]]$Seq[1])

print(covid_clonal_lineages[[1]][[1]]$Name[1]) #"clonotype3_1_IGHA1_AACCATGAGTGGAGTC-1"
## Here we can see that the above sequence corresponds to the original clonotype3 but is now the first clonal lineage (as seen by the _1_ before the isotype). Furthermore, the isotype of this cell was of the IGHA1. Lastly we have the barcode of the cell at the end, allowing us to look back at other cell-specific properties if wanted. 


print(covid_clonal_lineages[[1]][[3]]$Name[3]) #"clonotype7_3_IGHA1_AGTGAGGTCGAGAACG-1"
## Again, this was originally the 7th clonotype, and is now the third most clonally expanded lineage ("_3_"). Again of the IGHA1 isotype with the following barcode. 

print(tail(covid_clonal_lineages[[1]][[3]]$Name))  ## here at the end of the dataframe the user can also see the germline sequence, which has the "Name" of "germline". 



```

### 3.8 Neighbor-joining phylogenetic trees

The output of the VDJ_clonal_lineage function can be used as input to the VDJ_tree to produce quick, neighbor-joining phylogenetic trees. It is important that the VDJRegion is considered (or that the sequences from 10x have been trimmed) as this function does not involve a multiple string alignment - instead it creates a distance matrix from all sequences. The min number of unique sequences can be specified (e.g. if there are 50 cells in a clonl lineage, but only one unique antibody sequence, this tree will not be produced). Similarly the number of max sequences can be specified, which will cause then invoke random sampling. Plotting the first tree we can see the that there is one variant (named Seq_1) that has 90 cells (seen by the Freq_90) and it is very close to the germline (Seq_6_Freq_1). We know it is the germline because it is the highest sequence variant and it is set as the root. 

```{r, fig.show='hold'}


covid_trees <- VDJ_tree(clonal.lineages = covid_clonal_lineages,with.germline=T,min.sequences = 5,max.sequences = 30,unique.sequences = T)
plot(covid_trees[[1]][[1]])


```


### 3.9 Plotting per-cell isotype information 

Addition VDJ functions include plotting isotype distribution per clone. This can be performed by the VDJ_isotypes_per_clone function and setting the number of clones to show. The following code extracts and plots the isotype distribution of the top 30 clones. We can see a clear IgA isotype majority of the top four clones in the first patient 

```{r, fig.show='hold'}

covid_isotypes <- Platypus::VDJ_isotypes_per_clone(VDJ_clonotype_output = covid_vdj_repertoire_bcells, VDJ_per_clone_output = covid_single_cell, clones = 30)

print(covid_isotypes[[1]])

```

Whereas in the second patient (second repertoire entered in original VDJ_analyze) shows a similarly expanded IgA clone with over 60 cell barcodes. 
```{r, fig.show='hold'}

print(covid_isotypes[[2]])




```


### 3.10 Sequence similarity networks

Other functions are specifically tailored to repertoire analysis - such as VDJ_network, which creates a sequence similarity network between repertoires or within a repertoire by connecting those clones with sequence similarity. This function relies upon igraph to visually display and construct the graph - which means that networks with high number of sequences will not display easily. In the following example we take the top 60 most expanded clones from the output of VDJ_analyze and use this as input into the network construction function. Setting the per.mouse argument to false indicates that one network for multiple repertoires should be produced.  

```{r, fig.show='hold'}

library(igraph)

## Take the output from VDJ_analyze (or subsample as in this case the top 60 clones)
network_clones_covid <- list()
network_clones_covid[[1]] <- covid_vdj_repertoire_bcells[[1]][1:60,]
network_clones_covid[[2]] <- covid_vdj_repertoire_bcells[[2]][1:60,]


covid_bcell_igraph <- Platypus::VDJ_network(network_clones_covid[1:2],per.mouse = F,distance.cutoff = 8,connected = F)

igraph::plot.igraph(covid_bcell_igraph[[4]],vertex.label=NA,vertex.size=7+(.06*covid_bcell_igraph[[2]]$frequency),vertex.color=factor(covid_bcell_igraph[[2]]$mouse))





```

For more details see the documentation of the VDJ_network function, but essentially information such as clonal frequency and which sample (here still indicated by the "mouse" column) are stored in the second element of the output list. Here we can see only a few clones that are showing connections (produced by edges between those with 8 amino acid or less distance between heavy and light chain paired CDR3 sequence homology)


### 3.11 Germline gene usage heatmaps 

It is also possible to produce heatmaps of the germline gene usage in the context of heavy chain V gene and light chain V gene. The output of the VDJ_Vgene_usage function is a matrix for each repertoire corresponding to the order specified by VDJ_analyze. The outer list corresponds to the sample and the inner list corresponds to matrix, where the rows correspond to the heavy chain V genes and the columns correspond to the light chains of the V genes. Therefore the output[[1]][i,j] corresponds to the number of clones using the combination of IGH-Vgene[i] and IGK/L-Vgene[j]. Can be easily plotted as a heatmap to observe patterns between repertoires or can be used to calculate V gene correlation.  


```{r, fig.show='hold'}

# 
# covid_vj_gene_usage <- Platypus::VDJ_Vgene_usage(VDJ.clonotype.output = covid_vdj_repertoire_bcells)
# 
# print(class(covid_vj_gene_usage[[1]]))
# print(head(rownames(covid_vj_gene_usage[[1]])))
# print(head(colnames(covid_vj_gene_usage[[1]])))


```


## 4. Integrating repertoire and gene expression
 
The strength of the current 5' sequencing protocols are that the gene expression (GEX) and repertoire (VDJ) libraries are extracted from the same sample, which can then be linked back to demonstrate that a given T cell has a certain gene expression pattern and also a certain T cell receptor sequence. The following functions are meant to integrate these two pieces of information.

### 4.1 Integrating transcriptional clusters to the VDJ objects

One thing we may ask is how similar the B or T cells in a given clonal family are on the transcriptional level. One way we can do this is to take advantage of the transcriptional clustering performed in the automate_GEX function and then supply this information to the repertoire information. This can either be done on the level of the clone (e.g. in the format of the output of VDJ_analyze) or on the level of the cell (e.g. in the format of the output of VDJ_per_clone). Below is the example of the clonal level. The output is the same as the VDJ_analyze output, except now there are columns corresponding to the majority transcriptome cluster (e.g. if the majority of cells within the clone are in cluster 1, then this column will have a 1). Next to this there is the column that tells you the cluster percentage for all cells in that clone. Finally there is the cell index in the GEX object so you can see which cells are found in the GEX object and can explicitly call them. 

```{r, fig.show='hold'}

covid_integrating_clonal_level <- Platypus::VDJ_GEX_integrate(GEX.object = covid_gex[[1]], 
                                                 clonotype.list =  covid_vdj_repertoire_bcells,
                                                 VDJ.per.clone = covid_single_cell,
                                                 clonotype.level = TRUE)

print(head(covid_integrating_clonal_level[[1]]$majority_cluster))
print(head(covid_integrating_clonal_level[[1]]$cluster_membership_percent))
print(head(covid_integrating_clonal_level[[1]]$cell_index))


```

And now on the cell level - the output has a similar structure to the VDJ_per_clone function output. Again we can print out the cluster membership and the cell indicies for the 5th clone from the first patient's repertoire. If the cell is only found in the VDJ repertoire and not in the GEX repertoire, it will be a blank element. As seen by the 6th cell in this clonal family.


```{r, fig.show='hold'}

covid_integrating_cell_level <- VDJ_GEX_integrate(GEX.object = covid_gex[[1]], 
                                                 clonotype.list =  covid_vdj_repertoire_bcells[1:1],
                                                 VDJ.per.clone = covid_single_cell[1:1],
                                                 clonotype.level = FALSE)


print(head(covid_integrating_cell_level[[1]][[5]]$cluster_membership))
print(head(covid_integrating_cell_level[[1]][[5]]$cell_index))
```



### 4.2 Relating clonal expansion to transcriptional cluster membership

The VDJ_GEX_expansion function takes the previously integrated VDJ and GEX datasets and then plots the distribution of transcriptional cluster membership for the specified clones. In the following example, we plot the the top 20 clones and their distribution of cluster membership. We see that some clones did not have any barcodes overlapping between the GEX and VDJ data sets for this particular patient, and therefore has no bar at that given clonal index on the X axis. 

```{r, fig.show='hold'}

covid_clonotype_clusters_plot <-  Platypus::VDJ_GEX_expansion(GEX.list=covid_gex[[1]],
                                                              VDJ.GEX.integrate.list=covid_integrating_clonal_level,
                                                              highlight.isotype = "None",
                                                              highlight.number=1:20)


print(covid_clonotype_clusters_plot[[1]])


```

### 4.3 Visualizing clones on the 2 dimensional landscape

In the case we want to overlay clones on the tsne/umap space that we previously calculated using automate_GEX, this can be accomplished with the visualize_clones_GEX function. The following code will overlay the top 10 clones on the UMAP space calculated with the automate_GEX function. The group correspond to the clonal order - e.g. group 1 is the first clonal family in the integrated VDJ list. Here we can see that there are a few cells in the T cell cluster, suggesting that there were duplets during cell capture since in this experiment B and T cells were pooled in a single reaction. 

```{r, fig.show='hold'}

covid_top10_umap <- visualize_clones_GEX(GEX.list=covid_gex,
                     VDJ.GEX.integrate.list=covid_integrating_clonal_level[1:1],
                     highlight.type="clonotype",
                     highlight.number=1:10,
                     reduction="umap")
print(covid_top10_umap[[1]])

```



### 4.4 Specific gene expression information on the clonal level

We previously integrated the GEX information into the format of the VDJ output. However, we may want to ask how the gene expression looks for certain clonotypes. E.g. how many of the cells in the top clone are expressing Fas/GL7 or germinal center cell markers. For this we need to integrate the VDJ information and barcodes into the GEX object. This can first be done by using the clonotype_GEX function and then by the GEX_heatmap function. To save space the output of this function can be assigned to the original automate_GEX output, as it will be another Seurat object. By setting b.or.t to "b", a panel of pre-selected B cell genes will be displayed. One can also supply custom genes to test specific clonotypes. The group/column colors correspond to given clonal families. 

```{r, fig.show='hold'}

covid_gex_integrate <- clonotype_GEX(GEX.object=covid_gex[[1]],VDJ.per.clone = covid_single_cell)


covid_bcell_gene_heatmap <- GEX_heatmap(covid_gex_integrate,b.or.t = "b",clone.rank.threshold = 20,sample.index = 1)

```



### 4.5 Integrating clonal lineage information and transcriptional cluster information

We can also supply transcriptional cluster information into the clonal lineages organized earlier. This can be done using the VDJ_GEX_clonal_lineage_clusters function, which will place the transcriptional cluster information into the Name of the clonal_lineage object. Since we only integrated the first patient in the covid_integrating_cell_level object, we will just take the first patients clonal lineages. Now if we print the name of the first sequence in the first clonal lineage, we see that a cluster5 has been added to the end of the name. This indicates that this particular B cell was found in cluster5 from the original automate_GEX. 


```{r, fig.show='hold'}

clonal_lineage_integrate <- VDJ_GEX_clonal_lineage_clusters(covid_integrating_cell_level,covid_clonal_lineages[1:1])

print(clonal_lineage_integrate[[1]][[1]]$Name[1])

```





